#!/bin/sh
perl -x -S $0 "$@"
exit
# 4 \
# 5  \
# 6   \
# 7    > These lines are here so line numbers reported by perl will be off by exactly 10 (line
# 8   /  numbers are wrong because of the portable way we're executing this script).
# 9  /
#10 /
#!/usr/bin/perl

######################################################################################################
# Author: Robb Matzke <matzke@llnl.gov>
#
# Purpose:
#     The `mkdoc' system  was written by  Robb Matzke <matzke@llnl.gov> for  the purpose  of reading C
#     source files   and creating  documentation suitable  for  an application   programming reference
#     manual.
#
# Copyright(C) 1999 The Regents of the University of California.
#     This work  was produced, in  part, at the  University of California, Lawrence Livermore National
#     Laboratory    (UC LLNL)  under    contract number   W-7405-ENG-48 (Contract    48)   between the
#     U.S. Department of Energy (DOE) and The Regents of the University of California (University) for
#     the  operation of UC LLNL.  Copyright  is reserved to  the University for purposes of controlled
#     dissemination, commercialization  through formal licensing, or other  disposition under terms of
#     Contract 48; DOE policies, regulations and orders; and U.S. statutes.  The rights of the Federal
#     Government  are reserved under  Contract 48 subject  to the restrictions agreed  upon by DOE and
#     University.
# 
# Copyright(C) 1999 Sandia Corporation.
#     Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive license for use of this work
#     on behalf of the U.S. Government.  Export  of this program may require a license from the United
#     States Government.
# 
# Disclaimer:
#     This document was  prepared as an account of  work sponsored by an agency  of  the United States
#     Government. Neither the United States  Government nor the United States Department of Energy nor 
#     the  University  of  California  nor  Sandia  Corporation nor any  of their employees  makes any 
#     warranty, expressed  or  implied, or  assumes   any  legal liability  or responsibility  for the 
#     accuracy,  completeness,  or  usefulness  of  any  information, apparatus,  product,  or process 
#     disclosed,  or  represents that its  use would   not infringe  privately owned rights. Reference 
#     herein  to any  specific commercial  product,  process,  or  service by  trade  name, trademark, 
#     manufacturer,  or  otherwise,  does  not   necessarily  constitute  or  imply  its  endorsement, 
#     recommendation, or favoring by the  United States Government   or the University of  California.  
#     The views and opinions of authors expressed herein do not necessarily state  or reflect those of
#     the  United  States Government or  the   University of California   and shall  not be  used  for
#     advertising or product endorsement purposes.
# 
# Acknowledgements:
#     Robb P. Matzke              LLNL - Author of various tools
#     Mark C. Miller              LLNL - Alpha/Beta user; minor debugging/enhancements 
#     Matthew J. O'Brien          LLNL - Author of various tools
#     James F. Reus               LLNL - Alpha/Beta user

require 5.003;
use strict;

my($Home) = $0 =~ /^(.*)\/[^\/]*\/*$/;
my($Name) = $0 =~ /\/([^\/]+)$/;

sub usage {
  #  width:     --------------------------------------------------------------------------------
  print STDERR "Usage: $Name [SWITCHES] FILES...\n";
  print STDERR "  Source FILES are read and parsed to generate documentation.  The special file\n";
  print STDERR "  name \"-\" indicates that the sources should be read from the standard input\n";
  print STDERR "  stream. The main pages of documentation are produced on the standard output\n";
  print STDERR "  stream with auxilliary files created in the current working directory.  The\n";
  print STDERR "  valid command-line switches are:\n";
  print STDERR "\n";
  print STDERR "    -1            Deprecated. Use \"--toc=1\" instead.\n";
  print STDERR "    -a AUDIENCE   Restricts documentation to those functions and macros that\n";
  print STDERR "                  have the corresponding AUDIENCE tag in their prologues. For\n";
  print STDERR "                  instance, some libraries (like SAF) use the tags \"public\" and\n";
  print STDERR "                  \"private\" to control documentation scope. This switch may\n";
  print STDERR "                  be used more than once in order to broaden the scope of the\n";
  print STDERR "                  resulting document. The special AUDIENCE \"all\" means every-\n";
  print STDERR "                  thing will be documented.\n";
  print STDERR "    -c FILE       The mkdoc config file specifies how various things will be\n";
  print STDERR "                  formatted, particularly the title page.  By default, mkdoc\n";
  print STDERR "                  looks for the file \"Formats/library/META\" in the same\n";
  print STDERR "                  directory as the mkdoc script itself. See the sample META file\n";
  print STDERR "                  for an example on how to specify these configuration options.\n";
  print STDERR "    -C POSITION\n";
  print STDERR "                  Indicates whether a concept index should be generated and\n";
  print STDERR "                  whether it should be placed before or after the main body\n";
  print STDERR "                  of chapters. When a concept and permuted index both appear\n";
  print STDERR "                  at the beginning or the end the concept index will be first.\n";
  print STDERR "                  The POSITION can be \"none\", \"begin\", or \"end\".\n";
  print STDERR "    -d CLASSES    Specifies what classes of objects should be documented.\n";
  print STDERR "                  CLASSES should be a comma separated list of words to indicate\n";
  print STDERR "                  what should be documented, but if a word is prefixed with a\n";
  print STDERR "                  hyphen then that class of objects is not documented. This\n";
  print STDERR "                  switch may  appear more than once. The last occurance of each\n";
  print STDERR "                  class determines if documentation is enabled or disabled for\n";
  print STDERR "                  that class.  To get a list of possible classes specify \"list\".\n";
  print STDERR "    -E TAG        Specify documentation tags which should be excluded. If the\n";
  print STDERR "                  specified tag is the word \"list\" then a list of possible\n";
  print STDERR "                  tags will be displayed. This switch may appear multiple times.\n";
  print STDERR "    -f DOCTYPE    Controls the format of the output, where DOCTYPE should be\n";
  print STDERR "                  one of the words \"html\" (the default), \"mif\" (for FrameMaker\n";
  print STDERR "                  output), \"texi\" (from which can be generated GNU Info,\n";
  print STDERR "                  PostScript, etc), or \"text\" for plain text.\n";
  print STDERR "    -F FILE       Source file names are read from the specified FILE in addition\n";
  print STDERR "                  to any source file names that might appear on the mkdoc\n";
  print STDERR "                  command-line.  The file should contain one file name per line.\n";
  print STDERR "                  Lines containing only white space and lines beginning with a\n";
  print STDERR "                  hash or hyphen are ignored.\n";
  print STDERR "    -h or -?      Show this usage message.\n";
  print STDERR "    -l [CONFIG]   Limp-along mode. Normally undocumented entities will not make\n";
  print STDERR "                  it into the documentation. However, if this switch is\n";
  print STDERR "                  specified then all entities will be inserted into the output\n";
  print STDERR "                  regardless of whether they had a prologue, and entities\n";
  print STDERR "                  without a prologue will result in warnings. If CONFIG is given\n";
  print STDERR "                  then it should be a semicolon-separated list of KEY=VALUE\n";
  print STDERR "                  pairs (or multiple occurrences of the \"-l\" switch), where\n";
  print STDERR "                  KEY is one of the following words: audience, chapter, or\n";
  print STDERR "                  purpose. This supplies default values for prologues that are\n";
  print STDERR "                  missing these required parts. As a special case, if the\n";
  print STDERR "                  default chapter is specified as \"__CLASS__\" then functions\n";
  print STDERR "                  with no chapter specified will be placed in a chapter whose\n";
  print STDERR "                  name is the class portion of the function name (everything\n";
  print STDERR "                  up to the first colon).\n";
  print STDERR "    --multifile\n";
  print STDERR "    --singlefile\n";
  print STDERR "    -m            If \"-m\" or \"--multifile\" is specified and the output format\n";
  print STDERR "                  supports it then the output will be split into multiple files in\n";
  print STDERR "                  order to make interactive browsing easier. The default is to\n";
  print STDERR "                  produce one monolithic file suitable for printing.\n";
  print STDERR "    -o FILE       The name of the output file without the file extension (the\n";
  print STDERR "                  file extension is determined by the output format specified\n";
  print STDERR "                  with the \"-f\" switch). If this switch is omitted then the\n";
  print STDERR "                  word \"index\" is used. If the name includes a directory\n";
  print STDERR "                  component (or the entire name is a directory) then all other\n";
  print STDERR "                  output files (if the \"-m\" switch was supplied) will be written\n";
  print STDERR "                  to that same directory. The default directory is the current\n";
  print STDERR "                  working directory.\n";
  print STDERR "    -p DIRECTORY  For any of the source FILES which are not an absolute file\n";
  print STDERR "                  name mkdoc will search in the current working directory plus\n";
  print STDERR "                  any additional directories specified with this switch. This\n";
  print STDERR "                  switch may appear multiple times, in which case the search\n";
  print STDERR "                  progresses in the order that these switches are specified.\n";
  print STDERR "                  The current working directory is always searched first.\n";
  print STDERR "    -P POSITION\n";
  print STDERR "                  Indicates whether a permuted index should be generated and\n";
  print STDERR "                  whether it should be placed before or after the main body\n";
  print STDERR "                  of chapters. When a concept and permuted index both appear\n";
  print STDERR "                  at the beginning or the end the permuted index will follow\n";
  print STDERR "                  the concept index. The POSITION can be \"none\", \"begin\", or\n";
  print STDERR "                  \"end\".\n";
  print STDERR "    -s KEY=VALUE  Substitutes VALUE for every occurrence of \"\$KEY\". This switch\n";
  print STDERR "                  may be supplied multiple times.\n";
  print STDERR "    --toc=N\n";
  print STDERR "                  Controls the depth of the table of contents. A value of zero\n";
  print STDERR "                  means no table of contents will be generated. When N==1 the\n";
  print STDERR "                  table of contents will contain only a list of chapters. Any\n";
  print STDERR "                  higher value of N will create a nested table of containts\n";
  print STDERR "                  listing both chapters and sections.\n";
  print STDERR "    -u            Output will be unsorted.\n";
  print STDERR "    -v            Verbose output for debugging mkdoc.\n";
  print STDERR "    -x FILE       Use the specified summary file to generate cross references to\n";
  print STDERR "                  objects that are not actually documented by this run of mkdoc.\n";
  print STDERR "                  This is useful when running mkdoc on example source code which\n";
  print STDERR "                  makes references to an API which has already been documented.\n";
  print STDERR "                  This option may appear more than once.\n";
  #  width:     --------------------------------------------------------------------------------
  exit 1;
}

use Cwd;
use English;
use Text::Tabs;

BEGIN {
  my($dir) = $0 =~ /^(.*)\/[^\/]+$/;
  push @INC, $dir, "$dir/mkdoc-pm";
}

use Filename;			# File name parsing stuff

use Mkdoc::Html;		# HTML (Netscape) output format
use Mkdoc::Mif;			# MIF (FrameMaker) output format
use Mkdoc::Texi;		# TeXinfo (GNU Info) output format
use Mkdoc::Text;		# Plain text output format

use Mkdoc::Top;			# Title page, table of contents, etc.
use Mkdoc::Chapter;		# Chapter objects
use Mkdoc::Function;		# Function/macro objects
use Mkdoc::Type;		# Datatype objects
use Mkdoc::Note;		# Notes
use Mkdoc::Overload;		# Overloaded definitions
use Mkdoc::Section;		# Generic chapter sections

my(%Config);			# Configuration info
my(@Chapters, @Sections);	# List of all chapters and all sections
my(@Notes);			# List of all notes
my($PIChapter,$PIContent);	# Permuted index
my($CIChapter,$CIContent);	# Concept index
my($PIPosition,$CIPosition) = qw(end end); # Position of concept and permuted indices
my(%ExternalXRefs);		# External cross references
my($Top);			# Top node of the documentation

# Index of lexical elements
my($LexIndex,%LexIndex);

# Output context
my($Output);

# Command-line switches
my %SwitchSeen;                 # Has switch been seen? (indexed by switch name)
my @Audience;
my @ExcludeTags;
my $LimpAlong = 0;
my $ConfigFile = "$Home/Formats/library/META";
my $TocLevels;		        # number of levels in the table of contents
my $Sorted=1;			# not really a switch yet
my %Substitution;		# from the `-s' switch
my @SearchDirs;			# directories to search for source files
my $Verbose;			# generate more verbose output
my $FigureDir=".";		# root directory for figures referenced
my(@DocClasses);                # documentation classes, args of `-d' switch (c.f., %DocClasses)
my $OutputFmt="html";           # name of output format
my $Multipart;                  # produce multipart output if possible for the output driver?
my $OutputName="index";         # base name of the output file or directory (extension supplied by output format)
my @ExternalXRefsFiles;         # list of files or directories containing external xref info

# Valid function prologue tags. For tags that have both a singlular and plural form, use the plural
# form in the function prologue and either form in inline comments (this is only a convention). All
# singular tags will be stored using their plural forms in the prologue hash.
my @ValidTags = qw(Also Argument Arguments Audience Bug Bugs Issue Issues Chapter Concept Concepts Description
		   Modification Modifications Parallel Programmer Purpose Return Example);

# Documentation classes tell us what to document.  These are default values.
my %DocClasses = (functions=>1, prototypes=>0, pseudoenums=>1, macros=>1, enumerations=>1,
                  chapters=>1, notes=>1, sections=>1);

sub TRUE {1};
sub FALSE {0};

my $DefaultAudience = "unknown";
my @DefaultChapter; # see &bad_prologue
my $DefaultPurpose = "undocumented entitiy";

####################################################################################################
# Obtain file names from a file. Blank lines are ignored. Any line whose first non-space character
# is a hash or hyphen is also ignored.
sub obtain_file_names {
  my($listfile) = @_;
  my(@retval);
  local($_);

  open LIST, $listfile or die "$Name: cannot open `$listfile': $!\n";
  while (<LIST>) {
    chomp;
    next unless /\S/;
    next if /^\s*[-\#]/;
    push @retval, $_;
  }
  return @retval;
}

####################################################################################################
# Parse a command-line switch, consuming elements from the array of command arguments passed in.
# Returns true if a switch was parsed, negative otherwise.  This function aborts with an error
# message if there's something wrong with the switch.  If the first argument is `--default' then
# this function will return false if the switch has already been supplied.
sub switch {
  my($arglist) = @_;

  my $default = shift @$arglist if @$arglist && $arglist->[0] eq '--default';
  return unless @$arglist && $arglist->[0] ne '--' && $arglist->[0]=~/^-/;
  local $_ = shift @$arglist;

  sub defaulted {
    my($switch) = @_;
    return 1 if $default && $SwitchSeen{$switch};
    $SwitchSeen{$switch}++;
    return 0;
  }

  (/^-?$/ || /^-h$/ || /^--help$/) && usage; # doesn't return

  $_ = "-T$1" if /^--toc=(\d+)$/;
  $_ = "-T1" if $_ eq '-1';
  /^-T(\d)$/ && do {
    return if defaulted "T";
    $TocLevels = $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-a$/ && @$arglist;
  /^-a(.+)/ && do {
    return if defaulted "a";
    push @Audience, $1;
    @Audience=() if $1 eq 'all';
    return 1;
  };

  $_ .= shift @$arglist if /^-c$/ && @$arglist;
  /^-c(.+)$/ && do {
    return if defaulted "c";
    $ConfigFile = $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-C$/ && @$arglist;
  /^-C(.+)/ && do {
    my $pos = $1;
    unless (grep {$pos eq $_} qw/none begin end/) {
      print STDERR "concept index position must be: none, begin, end\n";
      exit 0;
    }
    return if defaulted "C";
    $CIPosition = $pos;
    return 1;
  };

  $_ .= shift @$arglist if /^-d$/ && @$arglist;
  /^-d(.+)/ && do {
    return if defaulted "d";
    push @DocClasses, split /[,\s]+/, $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-E$/ && @$arglist;
  /^-E(.+)/ && do {
    return if defaulted "E";
    my($tag) = $1;
    if ($tag eq 'list') {
      print STDERR "Valid tags for `-E' are: ", join(", ",map {lc} @ValidTags), "\n";
      print STDERR "(Singular and plural forms are equivalent.)\n";
      exit 0;
    } elsif (grep {lc $tag eq lc $_} @ValidTags) {
      push @ExcludeTags, lc $tag;
    } else {
      print STDERR "unknown tag `$tag' for `-E' switch. Use `-E list' to see valid tags.\n";
      exit 1;
    }
    return 1;
  };

  $_ .= shift @$arglist if /^-f$/ && @$arglist;
  /^-f(.+)/ && do {
    return if defaulted "f";
    $OutputFmt = $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-F$/ && @$arglist;
  /^-F(.+)/ && do {
    return if defaulted "F";
    push @$arglist, obtain_file_names $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-l$/ && @$arglist && $arglist->[0] =~ /^[a-z_A-Z]\w*=/;
  /^-l(.*)/ && do { # yes, argument is optional
    return if defaulted "l";
    $LimpAlong = 1;
    if ($_=$1) {
      foreach my $setting (split /;\s*/, $_) {
        my($key,$val) = split /=/, $setting, 2;
        if ($key eq 'audience') {
          $DefaultAudience = $val;
        } elsif ($key eq 'chapter') {
          push @DefaultChapter, $val;
        } elsif ($key eq 'purpose') {
          $DefaultPurpose = $val;
        } else {
          die "unknown `-l' key `$key'\n";
        }
      }
    }
    return 1;
  };

  $_ = "-m1" if /^--multifile$/;
  $_ = "-m0" if /^--singlefile$/;
  /^-m([01])?$/ && do {
    return if defaulted "m";
    $Multipart = $1 eq '0' ? 0 : 1;
    return 1;
  };

  $_ .= shift @$arglist if /^-o$/ && @$arglist;
  /^-o(.+)/ && do {
    return if defaulted "o";
    $OutputName = $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-p$/ && @$arglist;
  /^-p(.+)/ && do {
    return if defaulted "p";
    push @SearchDirs, $1;
    return 1;
  };

  $_ .= shift @$arglist if /^-P$/ && @$arglist;
  /^-P(.+)/ && do {
    my $pos = $1;
    unless (grep {$pos eq $_} qw/none begin end/) {
      print STDERR "permuted index position must be: none, begin, end\n";
      exit 0;
    }
    return if defaulted "P";
    $PIPosition = $pos;
    return 1;
  };

  $_ .= shift @$arglist if /^-s$/ && @$arglist;
  /^-s(.+)/ && do {
    return if defaulted "s";
    my $arg = $1;
    my($key,$value);
    die "invalid substitution argument: $arg\n" unless ($key,$value) = $arg =~ /^(.+?)=(.*)/;
    $Substitution{$key} = $value;
    return 1;
  };

  /^-u$/ && do {
    return if defaulted "u";
    $Sorted = undef;
    return 1;
  };

  /^-v$/ && do {
    return if defaulted "v";
    $Verbose++;
    return 1;
  };

  $_ .= shift @$arglist if /^-x$/ && @$arglist;
  /^-x(.+)/ && do {
    return if defaulted "x";
    push @ExternalXRefsFiles, $1;
    return 1;
  };

  print STDERR "$Name: unrecognized switch: \"$_\" (invoke with -h for usage information)\n";
  exit 1;
}

####################################################################################################
# Read the configuration file.
sub config {
  my($config,$configfile) = @_;
  local($_);

  sub config_save {
    my($tag,@args) = @_;
    $config->{$tag} ||= [];
    push @{$config->{$tag}}, join "\000", @args;
    if ($Verbose) {
      my(@short);
      for my $arg (@args) {
        $arg = substr($arg,0,30)."..." if length($arg) > 30;
        $arg =~ s/\n/\\n/g;
        push @short, $arg;
      }
      print STDERR "$Name:   $tag", (map{"{$_}"} @short), "\n";
    }
    return "";
  }

  sub config_switch {
    my($switch,@args) = @_;
    my(%switches) = (audience=>"-a", doctype=>"-f", document=>"-d", exclude=>"-E", limpalong=>"-l", multilevel=>"-T2", 
		     multipart=>"-m1", output=>"-o", singlelevel=>"-T1", singlepart=>"-m0", sources=>"-F", substitute=>"-s",
		     unsorted=>"-u", verbose=>"-v", concepts=>'-C', permuted=>'-P');
    return $switch . join "", map {"{$_}"} @args unless exists $switches{$switch};
    unshift @args, "--default", $switches{$switch};
    print STDERR "warning: `$switches{$switch}' from command-line overrides `\@$switch' in $configfile\n" unless switch \@args;
    return "";
  }

  # Read entire config file.  Deleting comments is a bit tricky because we want to recognize comments outside curly braces
  # but not inside. We do it very simply: delete any line that begins with a `#', then look for directives, then delete comments
  # that remain.
  open CONFIG, $configfile or die "cannot open $configfile: $!\n";
  $_ = join "", <CONFIG>;
  close CONFIG;
  print STDERR "$Name: reading configuration file: $configfile\n" if $Verbose;
  s/^\#.*//mg;

  # Three-arg
  s/@(copyright)\s*\{([^{}]*?)\}\s*\{([^{}]*?)\}\s*\{([^{}]*?)\}/config_save $1, $2, $3, $4/egs;

  # Two-arg
  s/@(copyright|rewrite)\s*\{([^{}]*?)\}\s*\{([^{}]*?)\}/config_save $1, $2, $3/egs;
  s/@(substitute)\s*\{([^{}]*?)\}\s*\{([^{}]*?)\}/config_switch $1, "$2=$3"/egs;

  # One-arg
  s/@(author|oldauthor|acknow|disclaimer|title|corder|navdir|figdir)\s*\{([^{}]*?)\}/config_save $1, $2/egs;
  s/@(audience|doctype|document|exclude|limpalong|output|sources)\s*\{([^{}]*?)\}/config_switch $1, $2/egs;
  s/@(concepts|permuted)\s*\{([^{}]*?)\}/config_switch $1, $2/egs;

  # No-arg
  s/@(singlelevel|limpalong|multilevel|multipart|unsorted|verbose)\b/config_switch $1/egs;

  # path names specified by @{navdir|figdir} directives are relative to the config file and
  # must be converted to absolute
  my($config_dir) = fn_split $configfile;
  if (exists $config->{navdir}) {
     my ($navdir) = fn_absolute $config->{navdir}[0], $config_dir;
     if (-d $navdir) {
        $config->{navdir} = $navdir;
     } else {
        $config->{navdir} = "";
     }
  }
  if (exists $config->{figdir}) {
     my ($figdir) = fn_absolute $config->{figdir}[0], $config_dir;
     if (-d $figdir) {
        $config->{figdir} = $figdir;
     } else {
        $config->{figdir} = "";
     }
  }

  # Check for things left over after we get rid of things that look like comments.
  s/\#(.*)//mg;
  if (/\S/) {
    s/^[ \t]+$//gm;
    print STDERR "$Name: configuration not understood:\n$_\n";
    exit 1;
  }
}

####################################################################################################
# Parse arguments:
sub parse_cmdline {
  my(@args) = @_;
  local($_);

 OPTION: 
  1 while switch \@args;

  # Read config file. We do this fairly early because it might augment the command-line switches
  config \%Config, $ConfigFile;
  $Config{navdir} ||= (fn_split $ConfigFile)[0];
  $Config{figdir} ||= (fn_split $ConfigFile)[0];
  $OutputName .= "/index" if -d $OutputName;

  # Hash the documentation classes
  for my $docclass (@DocClasses) {
    my($enabled) = 1;
    ($enabled,$docclass) = (0,$1) if $docclass =~ /^-(.*)/;
    if (exists $DocClasses{$docclass}) {
      $DocClasses{$docclass} = $enabled;
    } elsif ($docclass eq 'list') {
      print STDERR "Valid documentation classes for `-d' (and their current settings) are:\n";
      for my $dc (sort keys %DocClasses) {
        printf STDERR "  %-12s %s\n", $dc, $DocClasses{$dc}?"enabled":"disabled";
      }
      exit 0;
    } else {
      print STDERR "unknown documentation class `$docclass' for `-d' switch.\n";
      print STDERR "use `-d list' to see valid documentation classes.\n";
      exit 1;
    }
  }

  # Split the output name into components
  my($out_dir,$out_base) = fn_split $OutputName;
  $Config{outdir} = $out_dir;

  # Load external cross references
  my(%xrefs, @xreffilenames);
  for my $xname (@ExternalXRefsFiles) {
    my $optional;
    if ($xname =~ /^\?(.*)/) {
      $optional = 1;
      $xname = $1;
    }
    $xname .= ".toc" unless -e $xname;
    $xname = (glob "$xname/*.toc")[0] || "index.toc" if -d $xname;
    my($xdir,$xbase) = fn_split $xname;
    my $status = open XNAME, $xname;
    next if !$status && $optional;
    die "$xname: $!\n" if !$status;
    while (<XNAME>) {
      chomp;
      my($name,$objid) = (split /\000/)[0,2];
      $xrefs{$name} = $xdir . "/" . $objid;
    }
    close XNAME;
    push @xreffilenames, $xname;
  }
  @ExternalXRefsFiles = @xreffilenames;

  # Must have source files! Check this as late as possible but before we create any output.
  usage unless @args;

  # This is one of two places we need to know what output formats are available. The other place is
  # at the top of this script where we call `use' for each one.
  if ($OutputFmt eq 'texi') {
    $Output = Mkdoc::Texi->new($OutputName,%Config);
  } elsif ($OutputFmt eq 'html') {
    $Output = Mkdoc::Html->new($OutputName,%Config);
  } elsif ($OutputFmt eq 'mif') {
    $Output = Mkdoc::Mif->new($OutputName,%Config);
  } elsif ($OutputFmt eq 'text') {
    $Output = Mkdoc::Text->new($OutputName,%Config);
  } else {
    print STDERR "not a valid output format: $OutputFmt\n";
    exit 1;
  }
  $Output->multipart($Multipart);
  print STDERR "$Name: figure directory set to $Config{figdir}\n";

  # Creat external cross reference hash. We would do this earlier but it requires the
  # $Output driver, which in turn requires an output file.
  if (100 < keys %xrefs) {
    print STDERR "Loading external cross references from:\n";
    map {print STDERR "  $_\n"} @ExternalXRefsFiles;
  }
  %ExternalXRefs = $Output->load_exrefs($out_dir,%xrefs);

  # Create summary I/O file
  my($sumfile) = $OutputName . ".toc";
  open SUMMARY_FILE, ">$sumfile" or die "$sumfile: $!\n";

  # Create the top node.
  $Top = Mkdoc::Top->new(name=>$out_base);
  return @args;
}

####################################################################################################
# Error messages
my($CurFile,$CurFunc); # Location info for error messages
sub error {
  my($fmt,@args) = @_;
  printf STDERR "%s:%s: $fmt\n", ($CurFile||'<stdin>'), $CurFunc, @args;
}
sub fatal {
  error @_;
  die "That was fatal!\n";
}

####################################################################################################
# Expand tokens in source code
sub untokenize {
  my($string,$limit) = @_;
  $limit = 100 unless defined $limit;

  1 while $limit-->0 && $string =~ s/(@<[A-Z]{1,2}\d+>)/$LexIndex{$1}/ge;
  return $string;
}

####################################################################################################
# Turn a comment into a non-comment by removing the leading and trailing comment delimiters,
# removing the prefix which is common to all lines, and fixing whitespace in various ways.
sub decomment {
  my($preserve_indentation,@value) = @_;
  my($value,$nblank,$prefix,$i);

  # Remove leading and trailing stuff
  $value = join "\n", @value;
  $value =~ s/^\s*\/\*//; # Leading comment token
  $value =~ s/\s*\*\/\s*$//; # Trailing comment token
  $value =~ s/^\s*[*\|\/]*\s*//mg unless $preserve_indentation;
  @value = split /\n/, $value;

  # Find common prefix. Do not consider digits or letters to be part of a prefix if they are
  # conjoined with digits or letters immediately following.
  foreach $value (@value) {
    if ($value !~ /\w/) {
      $nblank++;
    } elsif (!defined $prefix) {
      $prefix = $value;
    } else {
      for ($i=0; $i<length($value) && $i<length($prefix); $i++) {
	if (substr($value, $i, 1) ne substr($prefix, $i, 1)) {
	  substr($prefix, $i) = "";
          $prefix =~ s/\w+$// if $prefix=~/\w$/ && substr($value,$i)=~/^\w/;
	  last;
	}
      }
    }
  }

  # Remove leading and trailing blank lines
  while (@value && $value[0] !~ /\S/) {
    shift @value;
    --$nblank;
  }
  while (@value && $value[-1] !~ /\S/) {
    pop @value;
    --$nblank;
  }

  # Remove common prefix and save the value, special case for single line.
  ($prefix) = $value[0]=~ /^([-\s*\|\/]*)/ if 1 == @value-$nblank;
  @value = map {substr $_, length $prefix} @value;

  # Remove leading and trailing blank lines again now that we removed the common prefix
  while (@value && $value[0] !~ /\S/) {
    shift @value;
    --$nblank;
  }
  while (@value && $value[-1] !~ /\S/) {
    pop @value;
    --$nblank;
  }

  return join "\n", @value;
}

####################################################################################################
# Given a reference to a prologue, insert the value for the specified tag. If each line of the value
# has a common prefix then that prefix is removed from each line.  This function dies if you attempt
# to insert a tag which already exists.
sub insert_tag {
  my($p_ref,$tag,@value) = @_;

  return unless $tag;
  error "tag `%s' is multiply defined", $tag if exists $p_ref->{$tag};
  local($_) = decomment TRUE, @value;
  $p_ref->{$tag} = $_ if /\S/;
}

####################################################################################################
# Checks that the prologue has the required tags and no unknown tags. Returns false only if the
# prologue looks okay.  If the prologue is missing a required field then a default is added by this
# function.  $pref is a reference to the prologue hash. The @valid array is an optional list of
# tags such that:
#    * any tag introduced with with a bang `!' is prohibited. This overrides tags that are
#      normally allowed or required.
#    * any tag introduced with an equal sign `=' is required. This is in addition to tags
#      that are normally considered to be required.
#    * any other tag is allowed but optional, overriding tags that are normally considered
#      to be invalid or required.
# An example is a Generic Section prologue, which requires `Section' and prohibits `Purpose'. The
# value would be @valid=('=Section', '!Purpose').
#
# The @DefaultChapter is an array of special symbols and chapter names that will be tried in order
# until one succeeds (if none succeed then a hard-coded default is used, see below):
#
#    __CLASS__    -- If the $name contains a colon then the chapter will be the class part, everything
#                    up to but excluding the first colon.
#
#    __FILE__     -- If this definition came from a named file (not standard input) then the chapter
#                    will be the name of the file.
#
#    Any Text     -- Will be placed in a chapter called "Any Text".
#
sub bad_prologue {
  my($pref,$name,@valid) = @_;
  my(@missing,@unknown,@prohibited);
  my(%valid);
  local($_);

  # Parse up the @valid array so that later things override earlier things. First
  # allow all recognized tags, then require a few things, then process the @valid
  # argument.
  for my $tag (@ValidTags) {
    $valid{$tag} = "Allowed";
  }
  $valid{Audience} = 'Required';
  $valid{Chapter} = 'Required';
  $valid{Purpose} = 'Required';
  for my $tag (@valid) {
    if ($tag =~ /^([!=])?(.*)/) {
      $valid{$2} = {'!'=>'Prohibited', '='=>'Required', ''=>'Allowed'}->{$1};
    }
  }

  # Look at each tag in the prologue to determine its status. We sort the keys
  # so that error messages printed below are sorted.
  for my $tag (sort keys %$pref) {
    if (!exists $valid{$tag}) {
      push @unknown, $tag;
    } elsif ($valid{$tag} eq 'Prohibited') {
      push @prohibited, $tag;
    } elsif ($valid{$tag} eq 'Required') {
      $valid{$tag} = 'Allowed'; # mark as having been encountered
    } elsif ($valid{$tag} eq 'Allowed') {
      # nothing
    } else {
      fatal "unrecognized tag mode";
    }
  }

  # Supply defaults for certain required but missing things
  if ($valid{Audience} eq 'Required') {
    $pref->{Audience} = $DefaultAudience;
  }
  if ($valid{Chapter} eq 'Required') {
    for my $dfltchap (@DefaultChapter) {
      if ($dfltchap eq "__CLASS__") {
        if ($name =~ /^([^:]+):/) {
          $pref->{Chapter} = "Class \u$1";
          last;
        }
      } elsif ($dfltchap eq "__FILE__") {
        if ($CurFile) {
          $pref->{Chapter} = "File $CurFile";
          last;
        }
      } else {
        $pref->{Chapter} = $dfltchap;
        last;
      }
    }
    $pref->{Chapter} ||= "Undocumented Entities";
  }
  if ($valid{Purpose} eq 'Required') {
    $pref->{Purpose} = $DefaultPurpose;
  }

  # Get a list of required tags that were missing
  @missing = grep {$valid{$_} eq 'Required'} sort keys %valid;

  # Errors
  error "missing tag(s): %s", join(", ",@missing) if @missing;
  error "unknown tag(s): %s", join(", ",@unknown) if @unknown;
  error "prohibited tag(s): %s", join(", ",@prohibited) if @prohibited;

  return 1 if @missing || @unknown || @prohibited;
  return 0;
}

####################################################################################################
# Given a prologue tag found in a comment, return the actual tag to use in the prologue hash. The
# $name argument is optional and corresponds to the special header called __NAME__ from the config
# file. When matching __NAME__ we'll split $name into components separated by /:+/ and try matching
# the right-most component, then the right and next-to-right components, etc. until a match is found.
sub rewrite_ptag {
  my($ptag,$name) = @_;
  my($rewrite);

  # Use rewrite rules from configuration file
  if ($Config{rewrite}) {
  REWRITE:
    foreach $rewrite (@{$Config{rewrite}}) {
      my($orig,$new) = split /\000/, $rewrite;
      if ($orig eq "__NAME__" && $name) {
        my(@name_comps) = split /:/, $name;
        $name = pop @name_comps;
        while (1) {
          if ($name eq $ptag) {
            $ptag = $new;
            last REWRITE;
          }
          last unless @name_comps;
          $name = pop(@name_comps) . ":" . $name;
        }
      } elsif ($orig eq $ptag) {
	$ptag = $new;
	last REWRITE;
      }
    }
  }

  # Convert to plural form
  $ptag .= "s" if grep {lc($ptag."s") eq lc $_} @ValidTags; #use plural form
  return $ptag;
}

####################################################################################################
# Process the function prologue and return a hash which is indexed by tag and whose value is the
# paragraphs for the tag.  The $name is optional and is only used by passing it to &rewrite_ptag.
# The @formals is a list of formal argument names for a function and any tag that matches an element
# of that list will not be passed through &rewrite_ptag.
sub save_prologue {
  my($prologue,$name,@formals) = @_;
  my($tag,@value,@extra,%retval);
  local($_);

  # remove leading and trailing stuff
  $prologue =~ s/^\/\*[-*\s]*(\n)?//;
  $prologue =~ s/[-*\s\n]*\*\/$//;

  foreach (split /\n/, $prologue) {
    my($prefix,$newtag,$colon,$first);
    s/\s+$//;

    # The $newtag might be a C++ function name, or it might just be two words.
    # The $colon to separate the tag from the text must be followed by a space.
    if (($prefix,$newtag,$colon,$first)=/^(\s{0,2}[|*\/]{0,2}\s{0,3})       # prefix
	                                ([a-zA-Z][:\w]*(?:[ ]+[a-z_A-Z]+)?) # tag (one or two words)
                                        ([ ]?:[ ]*)                         # colon  with optional pre-space
	                                (.*)/x) {                           # first line
      # We found a new tag. If the first line of its value is on the same line as the tag we save
      # the entire line but with the tag replaced by white space (to facilitate removal of common
      # prefixes later).
      insert_tag \%retval, $tag, @value; #save old tag
      $tag = $newtag;
      @value = ();
      if ($first) {
	$first = $prefix . (' 'x length $tag) . (' ' x length $colon) . $first;
	push @value, $first;
      }
      $tag = rewrite_ptag $tag,$name unless grep {$tag eq $_} @formals;
    } elsif ($tag) {
      push @value, $_;
    } else {
      push @extra, $_;
    }
  }
  insert_tag \%retval, $tag, @value;
  insert_tag \%retval, "extra text", @extra if @extra;
  chomp $retval{Chapter} if exists $retval{Chapter};
  return %retval;
}

####################################################################################################
# Look for special comments in the function body. These comments all begin with a recognized
# function prologue tag like `Tag:' or `TAG:', with one tag per comment. The contents of the comment
# will be typeset as its own paragraph in the documentation.
sub save_body_comment {
  my($prologue,$token) = @_;
  my($comment) = untokenize $token;
  return $token unless $comment =~ /(\/\*[-_\s\n*])([A-Z][a-zA-Z]*)[ ]?:(.*)/s;
  my($pre,$tag,$suf) = ($1,$2,$3);

  # Warn about unrecognized tags
  if (0 == grep {$tag eq $_ || $tag eq uc $_} @ValidTags) {
    error "unrecognized inline tag: %s\n", $tag;
    return $token;
  }

  # Append as a new paragraph
  $tag = lc $tag;
  $tag = "\u$tag";
  $tag .= "s" if grep {$tag."s" eq $_} @ValidTags; # make plural
  $prologue->{$tag} .= "\n\n" if $prologue->{$tag};
  $prologue->{$tag} .= decomment FALSE, "$pre$suf";
  return "";
}

####################################################################################################
# Is the function/macro within the scope of this manual?
sub within_scope {
  my($scope) = @_;
  return 1 unless @Audience; # default to `yes'

  my($word,$nmatches);
  foreach $word (split " ", $scope) {
    $nmatches += grep {lc $word eq lc $_} @Audience;
  }
  return $nmatches;
}

####################################################################################################
# Given a string, remove all occurrences of `(...%s...)'. This is used for error messages, precondition
# messages etc. that can occur in the reference manual and have additional information at runtime.
sub static_string {
  local($_) = @_;
  s/\([^\(\)]*%[^\(\)]*\)\s*//g;
  error "possible non-static string: %s", $_ if /%/;
  return $_;
}

####################################################################################################
#
sub precondition {
  my($expression,$cost,$return,$string) = @_;
  $string = static_string untokenize $string;
  print STDERR "$Name:       $string\n" if $Verbose;
  return join "\000", $expression, $cost, $string;
}

####################################################################################################
# Looks at formal argument documentation to see if the argument is marked as "in" (the default),
# "out", or "in-out" and returns one of three strings. The $docref is a reference to the
# argument documentation string and will be adjusted if one of the argument direction specifiers
# was present. */
sub argument_qualifiers {
  my($docref) = @_;
  my($dir);

  if ($$docref =~ /^(\s*)(in|out|in-?out):\s*(.*)/i) {
    $$docref = $1 . $3;
    $dir = uc $2;
  } elsif ($$docref =~ /^(\s*)\((in|out|in-?out)\)\s+(.*)/i) {
    $$docref = $1 . $3;
    $dir = uc $2;
  } elsif ($$docref =~ /^\s*(in|out|in-?out)\s*$/) {
    $$docref = "";
    $dir = uc $1;
  }

  $dir = "" if $dir eq "IN";
  $dir =~ s/IN-OUT/IN\/OUT/g;
  return $dir;
}

####################################################################################################
# Get the parts of a function and enter it into the %function hash as a reference to a hash with the
# keys:
#
#     file:     The name of the file containing the definition.
#     prologue: The function prologue, a reference to a hash whose keys are tags (like `Description')
#               which appear in the prologue.
#     rettype:  The function return type.
#     formals:  The formal argument list excluding the leading and trailing parentheses.
#     precond:  An array of preconditions.
#
# The function is not saved in the %function hash if it doesn't meet certain requirements necessary
# for its successful documentation. Return value is a list whose first element is stuff to reinsert
# into the parse stream and whose second element is the function object.
sub save_function {
  my($file,$prologue,$rettype,$name,$formals,$body,$source) = @_;
  my(@precond,@caveats,$audience,$retval);
  local($_);
  $CurFunc = $name;
  return $source if !$DocClasses{functions} && $body;
  return $source if !$DocClasses{prototypes} && !$body;
  print STDERR "$Name:   function $name\n" if $Verbose;

  # The function prologue could be zero one or two comments. If two comments appear and the second
  # comment is ARGSUSED then the first comment is the prologue, otherwise return the first comment
  # for additional processing.
  print STDERR "$Name:     expanding prologue\n" if $Verbose;
  if ($prologue =~ /(@<C\d+>)\s*(@<C\d+>)/) {
    my($c1,$c2) = ($1,$2);
    my($ec2) = untokenize($c2);
    if ($ec2 =~ /\/\*\s*ARGSUSED\s*\*\//) {
      $prologue = untokenize $c1;
    } else {
      $retval = $c1; #return to be parsed as something else
      $prologue = $ec2;
    }
  } else {
    $prologue = untokenize $prologue;
  }

  # Parse the formal argument list
  print STDERR "$Name:     parsing formal arguments\n" if $Verbose;
  my(@formals,@formal_names);
  $formals =~ s/^\s+//;		# kill leading white space
  $formals =~ s/\s+$//;		# and trailing white space
  unless ($formals eq 'void') {
    $formals =~ s/,\s*(@<C\d+>)/$1,/g;
    @formals = split /,\s*/, $formals;
    for my $i (0 .. @formals-1) {
      my($type,$name,$array,$doc);
      if ($formals[$i] =~ /^[a-z_A-Z]\w*$/) {
	$name = $formals[$i];
      } elsif ($formals[$i] =~ /^\.\.\.\s*(@<C\d+>)?\s*$/) {
	$name = '...';
	$doc = $1;
      } else {
	($type,$name,$array,$doc) =
	  $formals[$i] =~ /^(\w+(?:\s+\w+)*          # type name
			     (?:\s+|(?:\s*[\*&]\s*)+)) # type pointers
	                   (\w+)\s*                  # formal name
			   ((?:\[.*?\]\s*)*)         # optional array spec
			   (?:(@<C\d+>)?\s*)         # optional documentation
                           $
			  /x;
	($name,$doc) = $formals[$i] =~ /^(\w+)\s*(?:(@<C\d+>)?\s*)$/ unless $name;
	unless ($name) {
	  error "cannot parse formal: `%s'", $formals[$i];
	  next;
	}
      }
      $type =~ s/\s{2,}/ /g;                #squeeze out multiple spaces
      $type =~ s/\s+$//;                    #remove trailing spaces
      $type =~ s/(\w)\*/$1 */g;	            #space between name and star
      $type .= ' ' if $type =~ /\w$/;       #add a trailing space
      $doc = decomment FALSE, untokenize $doc; # fix up the documentation string
      my $qualifiers = argument_qualifiers \$doc;
      $formals[$i] = {type=>$type, name=>$name, array=>$array, qualifiers=>$qualifiers, doc=>$doc};
      $formal_names[$i] = $name;
    }
  }

  # Check prologue. The prologue may be the comment /*DOCUMENTED*/
  print STDERR "$Name:     parsing prologue\n" if $Verbose;
  if (!$prologue) {
    return $retval unless $LimpAlong;
    error "no function/macro prologue";
  } elsif ($prologue =~ /\/\*\s*DOCUMENTED\s*\*\//) {
    return $retval;
  }
  my %prologue = save_prologue $prologue,$name,@formal_names;
  return if bad_prologue(\%prologue,$name,@formal_names) && !$LimpAlong;
  $rettype =~ s/\s+$//;

  # Look for formal argument documentation in the prologue and move it into the @formals list.
  for my $i (0 .. @formals-1) {
    if (exists $prologue{$formals[$i]{name}}) {
      $formals[$i]{doc} = $prologue{$formals[$i]{name}} . "\n\n" . $formals[$i]{doc};
      delete $prologue{$formals[$i]{name}};
    }
  }

  # Look for preconditions in the body w/o modifiying the body. This is very SAF-specific and the regular
  # expression could be much more efficient if the error string was first instead of last.
  print STDERR "$Name:     parsing pre-conditions\n" if $Verbose;
  $_ = $body;
  s/\bSAF_REQUIRE\s*\(
    \s*((?:.|\n)+?)\s*,		            # The expression
    \s*([A-Z_]+)\s*,		            # Check cost
    \s*((?:.|\n)+?)\s*,                     # Return value
    \s*_?saf_errmsg\s*\(\s*(@<S\d+>)        # Error string (funtion is with or without leading underscore)
      /push @precond, precondition $1, $2, $3, $4/gexs;

  # Look for special comments in the body
  print STDERR "$Name:     parsing body comments\n" if $Verbose;
  $body =~ s/(@<C\d+>)/save_body_comment \%prologue, $1/eg;

  # Save the function
  print STDERR "$Name:     creating internal representation\n" if $Verbose;
  return $retval unless within_scope $prologue{Audience};
  my($func) = Mkdoc::Function->new(name=>$name, file=>$file, prologue=>\%prologue,
				   rettype=>$rettype, formals=>\@formals,
				   body=>$body, precond=>\@precond, source=>untokenize $source);
  if (ref $func) {
    print STDERR "$Name:     cross reference notation\n" if $Verbose;
    push @Sections, $func;
    $Output->xref_list($name,$Output->xref2($func->objid,$name));
  } else {
    error $func;
  }
  return ($retval,$func);
}

####################################################################################################
# Get the parts of a macro and enter it into the %function hash as a reference to a hash with the
# same keys as for functions, except `rettype', and `precond' don't make any sense for macros. The
# return value is a list whose first element is a string to reinsert into the parse stream and whose
# second element is the macro object.
sub save_macro {
  my($file,$prologue,$defn,$source) = @_;
  return unless $DocClasses{macros};
  $defn = untokenize $defn,1;
  return unless $defn =~ /^\#\s*define\s+      # the `#define' part
                        ([a-z_A-Z]\w*)         # the macro name
		        (\((.*?)\))?           # optional formal arguments
			(.*)/sx;
  my ($name,$formals,$body) = ($1,$3,$4);

  my($retval,$func) = save_function $file, $prologue, "", $name, $formals, $body, $source;
  return unless ref $func;
  $func->is_macro(TRUE);
  return ($retval,$func);
}

####################################################################################################
# Save an enumeration datatype. The return value is a list whose first element is a string to reinsert
# into the parse stream and whose second element is the enumeration object.
sub save_enum {
  my($file,$prologue,$decl,$name,$members,$typedef,$source) = @_;
  return unless $DocClasses{enumerations};
  my($member,@definitions);
  my($prev_val) = -1;
  local($_);

  # Fix name based on whether this is a typedef
  if ($decl =~ /^typedef/) {
    $CurFunc = $typedef;
    $name = $typedef;
  } else {
    $CurFunc = "enum $name";
  }

  # Enums can be anonymous
  $name ||= "anonymous";
  print STDERR "$Name:   enum $name\n" if $Verbose;

  # Check prologue
  $prologue = untokenize $prologue;
  return if $prologue =~ /\/\*\s*DOCUMENTED\s*\*\//;
  if (!$prologue) {
    return "" unless $LimpAlong;
    error "no enumerated type prologue";
  }
  my(%prologue) = save_prologue $prologue,$name;
  return if bad_prologue(\%prologue,$name) && !$LimpAlong;

  # Create the enum object
  return "" unless within_scope $prologue{Audience};
  my($type) = Mkdoc::Type->new(name=>$name, pseudo=>0, file=>$file, prologue=>\%prologue,
			       definitions=>\@definitions, source=>untokenize $source);
  unless (ref $type) {
    error $type;
    return ("",$type);
  }

  # Save definitions. The $type object has a reference to @definitions, so we're actually updating
  # the enumeration datatype at this point.  The cross references are to potentially overloaded
  # definitions. Even if we did want them to point to a specific definition we couldn't do that
  # here because we're not finished defining objects (the $type->objid could still change).
  $Output->xref_list($name,$Output->xref2($type->name,$name));
  $members =~ s/\n/ /g;
  $members =~ s/,\s*(@<C\d+>)/$1,/g;
  foreach $member (split /\s*,\s*/, $members) {
    my($sym,$value,$comment) = $member =~ /^\s*([a-z_A-Z]\w*)(?:\s*=\s*(.*?)\s*)?\s*(@<C\d+>)?\s*$/;
    push @definitions, {name=>$sym, value=>$value, comment=>decomment FALSE, untokenize $comment};
    $Output->xref_list($sym, $Output->xref2($type->name,$sym))
  }

  # Save results
  push @Sections, $type;
  return ("",$type);
}

####################################################################################################
# Save a pseudo-enum for later.  A pseudo-enum is a list of related preprocessor symbol definitions
# which serve as aliases for integers or enumeration constants.  All symbols in the related set will
# have a common prefix which will be taken as the name of the enumeration type. The return value is a
# list whose first element is a string to reinsert into the parse stream and whose second element is
# the psuedo-enum object.
sub save_penum {
  my($file,$prologue,$typedef,$defn,$source) = @_;
  return unless $DocClasses{pseudoenums};
  my(@definitions);
  local($_);

  my($name) = $typedef =~ /typedef\s+\w+\s+(?:\*\s*)*(\w+)/;
  $CurFunc = $name || "unamed pseudo-enum";

  # Split the $defn into a list of #define's
  my(@defn) = split /\n/, $defn;
  foreach (@defn) {
    my($d,$c) = /(@<PD\d+>)/;
    $d = untokenize $d, 1;
    ($d,$c) = $d =~ /(.*?)(?:(@<C\d+>)\s*)?$/;
    $c = untokenize $c;
    my($name,$args,$value) = $d =~ /^\#\s*define\s+(\w+)(\(.*?\))?\s+(.*?)\s*$/;
    return $source if $args; # not a pseudo-enum because something is a macro
    push @definitions, {name=>$name, value=>$value, comment=>decomment FALSE, $c};
  }

  # Compute the common prefix for the names -- this is the type name. If the type
  # name is empty then this must just be a list of preprocessor symbols.
  unless ($name) {
    my($prefix);
    foreach (@definitions) {
      my($value) = $_->{name};
      if (!defined $prefix) {
	$prefix = $value;
      } else {
	my($i);
	for ($i=0; $i<length($value) && $i<length($prefix); $i++) {
	  if (substr($value, $i, 1) ne substr($prefix, $i, 1)) {
	    substr($prefix, $i) = "";
	    last;
	  }
	}
      }
    }
    $prefix =~ s/_$//;
    return $source if $prefix eq "";
    $CurFunc = $name = $prefix; # we know our name now ;-)
  }
  print STDERR "$Name:   pseudo enum $CurFunc\n" if $Verbose;

  # Check prologue.
  $prologue = untokenize $prologue;
  return if $prologue =~ /\/\*\s*DOCUMENTED\s*\*\//;
  if (!$prologue) {
    return "" unless $LimpAlong;
    error "no pseudo-enum prologue";
  }
  my(%prologue) = save_prologue $prologue,$name;
  return if bad_prologue(\%prologue,$name) && !$LimpAlong;

  # Create the type object
  return "" unless within_scope $prologue{Audience};
  my($type) = Mkdoc::Type->new(name=>$name, pseudo=>1, file=>$file, prologue=>\%prologue,
			       definitions=>\@definitions, source=>untokenize $source);
  unless (ref $type) {
    error $type;
    return ("",$type);
  }

  # Initialize cross-reference hash. The cross references are to potentially overloaded
  # definitions. Even if we did want them to point to a specific definition we couldn't do that
  # here because we're not finished defining objects (the $type->objid could still change).
  $Output->xref_list($name,$Output->xref2($type->name,$name));
  foreach (@definitions) {
    $Output->xref_list($_->{name}, $Output->xref2($type->name,$_->{name}));
  }

  # Save results
  push @Sections, $type;
  return ("",$type);
}

####################################################################################################
# Save comments about a chapter generic section. A generic section is simply a function prologue with
# the keyword `Section' in place of `Purpose' and without any program construct (e.g., a function
# definition) appearing afterward.
sub save_section {
  my($file,$prologue) = @_;
  return unless $DocClasses{sections};
  $CurFunc = "generic section";

  # Check prologue. In order to be a section, the prologue must contain the keyword `section'.
  my %prologue = save_prologue untokenize $prologue;
  return $prologue unless exists $prologue{Section};
  $CurFunc = $prologue{Section};
  print STDERR "$Name:   generic section \"$CurFunc\"\n" if $Verbose;
  return if bad_prologue(\%prologue,undef,"!Purpose", "=Section") && !$LimpAlong;

  # Save the section
  my($section) = Mkdoc::Section->new(name=>$prologue{Section}, prologue=>\%prologue);
  if (ref $section) {
    push @Sections, $section;
  } else {
    error $section;
  }
  return ("", $section);
}

####################################################################################################
# Save comments that document entire chapters of the reference manual. They look like our normal
# prologue comments except they have only `Audience', `Chapter', and `Description' fields (an
# `Issues' field is optional). The return value is a list whose first element is a string to be
# reinserted into the parse stream and whose second element is the chapter object.
sub save_chapter {
  my($file,$prologue) = @_;
  return unless $DocClasses{chapters};
  $CurFunc = "chapter heading";
  my(%prologue) = save_prologue untokenize $prologue;

  # `Description' is required instead of `Purpose'
  return $prologue unless $prologue{Chapter};
  return "" if bad_prologue \%prologue, undef, "!Purpose", "=Description";
  $CurFunc = $prologue{Chapter};
  print STDERR "$Name:   chapter \"$CurFunc\"\n" if $Verbose;

  # Save chapter
  return "" unless within_scope $prologue{Audience};
  my($chap) = Mkdoc::Chapter->new(name=>$prologue{Chapter}, prologue=>\%prologue,
				  sorted=>$Sorted, file=>$file);
  if (ref $chap) {
    push @Chapters, $chap;
  } else {
    error $chap;
  }
  return ("",$chap);
}

####################################################################################################
# Save comments that serve as notes to be referenced by other documentation. They have two tags:
# `Note' is the unique name of the note, capitalized for section name and not punctuated.
# `Description' is the content of the note.
sub save_note {
  my($file,$prologue) = @_;
  return unless $DocClasses{notes};
  $CurFunc = "note";
  my(%prologue) = save_prologue untokenize $prologue;

  # Required fields (and only fields)
  return $prologue unless exists $prologue{Note};
  $CurFunc = $prologue{Note};
  print STDERR "$Name:   note \"$CurFunc\"\n" if $Verbose;
  return if bad_prologue(\%prologue,undef,"!Chapter","!Purpose","Audience","=Note") && !$LimpAlong;
  $prologue{Chapter} = "Notes";

  # Save the note
  my($note) = Mkdoc::Note->new(name=>$prologue{Note}, prologue=>\%prologue);
  if (ref $note) {
    push @Notes, $note;
  } else {
    error $note;
  }
  return ("", $note);
}

####################################################################################################
# Typeset a permuted index composed of function names and their purpose. The function names are
# broken into words separated by underscores.
sub pindex {
  my(@uninteresting_words) = qw(a an and as by for from in of or that the to which with);
  my(%word,$word,@index,$entry,@entry,@object);
  my($objnum) = 0;
  local($_);

  print STDERR "  [Permuted Index]\n";

  # Gather the index info
  foreach (@Sections) {
    my(@post,@pre) = split " ", $_->prologue->{Purpose};
    while (@post) {
      my $word = $post[0];
      next if grep {lc $word eq $_} @uninteresting_words;
      push @index, join "\000", (join(" ", @post), join(" ", @pre), $objnum);
    } continue {
      push @pre, shift @post;
    }
    $object[$objnum++] = $_;
  }

  # Generate the index entries
  foreach $entry (sort {lc $a cmp lc $b} @index) {
    my($post,$pre,$objnum) = split /\000/, $entry;
    push @entry, $Output->pindex_item($object[$objnum],$pre,$post);
  }
  @entry = grep /\S/, @entry;

  # Generate the index
  if (@entry) {
    my($index) = Mkdoc::Chapter->new(name=>"Permuted Index",sorted=>1);
    my($all) = $Output->chapter($index,undef,$Output->pindex(@entry));
    return ($index,$Output->multi_output($index,$all));
  }
  return (undef,undef);
}

####################################################################################################
# Typeset the concept index.
sub cindex {
  my($concept,$name,@index,@entry,@object);
  my($objnum) = 0;
  local($_);

  print STDERR "  [Concept Index]\n";

  # Gather the index info
  foreach $_ (@Sections) {
    foreach $concept (split /[;\n]/, $_->prologue->{Concepts}) {
      $concept =~ s/^\s+//;
      $concept =~ s/\s+$//;
      push @index, join "\000", $concept, $objnum;
    }
    $object[$objnum++] = $_;
  }

  # Generate index entries
  foreach (sort @index) {
    ($concept,$objnum) = split /\000/;
    push @entry, $Output->cindex_item($object[$objnum],$concept);
  }
  @entry = grep /\S/, @entry;

  # Generate the index
  if (@entry) {
    my($index) = Mkdoc::Chapter->new(name=>"Concept Index",sorted=>1);
    my($all) = $Output->chapter($index,undef,$Output->cindex(@entry));
    return ($index,$Output->multi_output($index,$all));
  }
  return (undef, undef);
}

####################################################################################################
# Typeset a table of contents. This is a two-level table of contents. The top level lists the
# chapters and the inner layer lists the functions; both are alphabetical.
sub toc {
  my($chapter,@chapters);
  print STDERR "  [Table of Contents]\n";

  # Generate indices
  ($PIChapter,$PIContent) = pindex if $PIPosition ne "none";
  ($CIChapter,$CIContent) = cindex if $CIPosition ne "none";;

  # Add indices to beginning of table of contents
  push @chapters, $Output->toc_item($PIChapter) if $PIChapter && $PIPosition eq "begin";
  push @chapters, $Output->toc_item($CIChapter) if $CIChapter && $CIPosition eq "begin";

  # Body
  foreach $chapter (@Chapters) {
    my($section,@sections);
    push @chapters, $Output->toc_item($chapter);
    if ($TocLevels>1) {
      foreach $section ($chapter->get_members($Sorted)) {
	push @sections, $Output->toc_item($section);
      }
      push @chapters, $Output->toc(undef,@sections);
    }
  }

  # Add indices to end of table of contents
  push @chapters, $Output->toc_item($PIChapter) if $PIChapter && $PIPosition eq "end";
  push @chapters, $Output->toc_item($CIChapter) if $CIChapter && $CIPosition eq "end";

  # Render table of contents
  my($toc) = Mkdoc::Chapter->new(name=>"Table of Contents",sorted=>$Sorted);
  return $Output->chapter($toc,undef,$Output->toc(undef,@chapters));
}

####################################################################################################
# Sort chapters.
sub sort_chapters {
  my($warnings,@chapters) = @_;
  my(@retval,$name);

  # Suck out chapters that are mentioned in @corder directives, complaining about directives
  # that mention nonexistent chapters.
  foreach $name (@{$Config{corder}}) {
    push @retval, grep {$_->name eq $name} @chapters;
    @chapters = grep {$_->name ne $name} @chapters;
  }

  # Sort remaining chapters by name and complain about each
  @chapters = sort {$a->name cmp $b->name} @chapters;
  map {warn "chapter `".$_->name."' will appear in default order (no \@corder directive)\n"} @chapters;
  push @retval, @chapters;
  return @retval;
}

####################################################################################################
####################################################################################################
#				      M A I N   P R O G R A M
#					F I R S T   P A S S
####################################################################################################
####################################################################################################
my(@sourcefiles) = parse_cmdline @ARGV;
print STDERR "$Name: pass 1: gathering information...\n";

# The main loop reads each source file, looks for things that appear to be function definitions, and
# invokes the do_function() sub for each in order to gather the information.
my($sourcefile,$src);
foreach $sourcefile (@sourcefiles) {
  # Suck in an entire source file at a time because it makes multi-line pattern matching much easier
  # at the expense of more difficult line numbers in error messages.
  print STDERR "$Name: parsing $sourcefile\n" if $Verbose;
  if ($sourcefile eq '-') {
    $sourcefile = "";
    $CurFile = "";
    $src = join "", expand <STDIN>;
  } else {
    if (! -e $sourcefile && $sourcefile !~/^\//) {
      my($path);
      foreach $path (@SearchDirs) {
	if (-e "$path/$sourcefile") {
	  $sourcefile = "$path/$sourcefile";
	  last;
	}
      }
    }
    $CurFile = $sourcefile;
    open SRC, "$sourcefile" or fatal "%s", "$!";
    $src = join "", expand <SRC>;
    close SRC;
  }
  printf STDERR "$Name: read %d lines from $sourcefile\n", scalar(split /\n/, $src) if $Verbose;

  # Perform substitutions
  {
    my($key);
    print STDERR "$Name: performing substitutions\n" if $Verbose;
    foreach $key (keys %Substitution) {
      $src =~ s/\$$key\b/$Substitution{$key}/g;
    }
  }

  # Replacing certain lexical elements with `@<X#>' where `X' is the class designator, in order to
  # make parsing easier.
  #   C    = comment
  #   P    = preprocessor statement
  #   S    = string
  # The `#' is a unique number. `@' characters that appear in the original input stream are replaced
  # by `@@' when they appear outside one of the lexical elements described above.
  sub lexize {
    local($_) = @_;
    my($class,$append);

  SW:{
      /^\/\*/            && ($class="C",                last SW);
      /^\/\//            && ($class="C",  $append="\n", last SW);   # return "\n"; # discard C++ comments
      /^[\"\']/          && ($class="S",                last SW);
      /^\#\s*define\b/   && ($class="PD",               last SW);
      /^\#\s*undef\b/    && ($class="PU",               last SW);
      /^\#\s*if(def)?\b/ && ($class="PC",               last SW);
      /^\#\s*ifndef\b/   && ($class="PC",               last SW);
      /^\#\s*else\b/     && ($class="PC",               last SW);
      /^\#\s*elif\b/     && ($class="PC",               last SW);
      /^\#\s*endif\b/    && ($class="PC",               last SW);
      /^\#/              && ($class="PO",               last SW);
      die "cannot lexize `$_'";
    }
    $class = "@<$class" . $LexIndex++ . ">";
    $LexIndex{$class} = $_;
    return $class . $append;
  }

  # Comments and strings need to be done simultaneously before preprocessor directives (preprocessor
  # directives may contain @C and @S elements).
  {
    print STDERR "$Name: lexical analysis for comments and strings\n" if $Verbose;
    my($start) = $LexIndex;
    $src =~ s/(  # C Comments
	       \/\*.*?\*\/
	       | # C++ comments, treating multple lines as a single comment
	       \/\/[^\n]*\n([ ]*\/\/[^\n]*\n)*
	       | # Strings, single or double quotes
	       ([\"\']) (\\.|[^\3])*? \3             # WATCH OUT -- paren references!!!
	      )/lexize $1/segx;
    printf STDERR "$Name: parsed %d comments and strings\n", $LexIndex-$start if $Verbose;
  }

  {
    print STDERR "$Name: lexical analysis for preprocessor statements\n" if $Verbose;
    my($start) = $LexIndex;
    $src =~ s/(  # Preprocessor statements may continue across lines
	       (^\#([^\n]*\\\n)*[^\n]*)
	      )/lexize $1/megx;
    $src =~ s/@(?!<)/@@/g;
    printf STDERR "$Name: parsed %d preprocessor statements\n", $LexIndex-$start if $Verbose;
  }

  # Look for notes. The comment must begin in the first column.
  print STDERR "$Name: parsing note comments\n" if $Verbose;
  $src =~ s/^(@<C\d+>)
    /(save_note $sourcefile, $1)[0]/xmeg;

  # Look for generic section comments. Chapters generally have either sections corresponding to
  # program elements (functions, macros, etc) or generic sections described by these comments,
  # but not both.
  print STDERR "$Name: parsing generic sections\n" if $Verbose;
  $src =~ s/^(@<C\d+>)
    /(save_section $sourcefile, $1)[0]/xmeg;

  # Look for a comment followed by a function declaration (prototype). The comment must begin in
  # the first column as must the function return type.
  print STDERR "$Name: parsing function prototypes\n" if $Verbose;
  $src =~ s/^((?:@<C\d+>\s*\n){0,2})                            # optional prologue & lint comment
	    ^([a-z_A-Z]\w*(?:\s+[a-z_A-Z]\w*)*(?:\s*\*+\s*|\s+)) # return type
            ([a-z_A-Z][\w:]*)\s*                                # function name
            \(([\s\n\w\[\],@<>*&\.]*)\)                         # formal args
            \s*;                                                # end of statement
           /(save_function $sourcefile, $1, $2, $3, $4, "", $MATCH)[0]/xmeg;

  # Look for a comment followed by a function definition. The comment must begin in the first column
  # as must the function return type.
  print STDERR "$Name: parsing function definitionss\n" if $Verbose;
  $src =~ s/^((?:@<C\d+>\s*\n){0,2})                            # optional prologue & lint comment
            ^(?:@<PC\d+>\n)?                                    # cpp conditional directive
	    ^([a-z_A-Z]\w*(?:\s+[a-z_A-Z]\w*)*(?:\s*\*+\s*|\s+)) # return type
	    ([a-z_A-Z][\w:]*)\s*                                # function name
	    \(([\s\n\w\[\],@<>*&^\.]*)\)                        # formal args
            [\s\n]*(\{(?:.|\n)*?\n\})                           # body
            [\s\n]*                                             # trailing space
    /(save_function $sourcefile, $1, $2, $3, $4, $5, $MATCH)[0]/xmeg;

  # Look for a comment followed by a pseudo-enum (a list of #define symbols, none of which take
  # arguments).
  print STDERR "$Name: parsing pseudo-enum types\n" if $Verbose;
  $src =~ s/^(?:(@<C\d+>)\s*\n)?                                # optional prologue
            (typedef\s+\w+\s+\*?\w+\s*;(?:\s*@<C\d+>)?\s*\n)?   # optional typedef
            ((^@<PD\d+>[\ ]*\n){2,})                            # definitions
    /(save_penum $sourcefile, $1, $2, $3, $MATCH)[0]/xmeg;

  # Look for a comment followed by a macro definition. The comment must begin in the first column.
  print STDERR "$Name: parsing preprocessor macros and constants\n" if $Verbose;
  $src =~ s/^(?:(@<C\d+>)\s*\n)?                                # optional prologue
            ^(@<PD\d+>)
    /(save_macro $sourcefile, $1, $2, $MATCH)[0]/xmeg;

  # Look for a comment followed by an enum definition. The comment must begin in the first column.
  print STDERR "$Name: parsing enumeration types and typedefs\n" if $Verbose;
  $src =~ s/^(?:(@<C\d+>)\s*\n)?                                # optional prologue
            ((?:typedef\s+)?enum)                               # declaration
            \s+([a-z_A-Z]\w*)?                                  # optional enum name
            \s*\{((?:.|\n)*?)\}                                 # enum body
            (?:\s*([a-z_A-Z]\w*))?                              # optional typedef name
    /(save_enum $sourcefile, $1, $2, $3, $4, $5, $MATCH)[0]/xmeg;

  # Look for comments that describe entire chapters. The comment must begin in the first column.
  print STDERR "$Name: parsing chapter comments\n" if $Verbose;
  $src =~ s/^(@<C\d+>)
    /(save_chapter $sourcefile, $1)[0]/xmeg;

#  print STDERR map {"||$_\n"} split /\n/, $src;
}

####################################################################################################
####################################################################################################
#				      M A I N   P R O G R A M
#				       S E C O N D   P A S S
####################################################################################################
####################################################################################################
print STDERR "$Name: pass 2: Sorting objects...\n";
{
  # Build an index of chapters by name
  print STDERR "  [Obtaining chapter list]\n";
  my(%chapter);
  @Chapters = Mkdoc::Chapter->mklinks(Mkdoc::Chapter->list); # ALL chapters
  foreach (@Chapters) {
    $chapter{$_->name} ||= $_; # only first of overloaded names
  }

  # Assign each section to a chapter, creating additional chapters as needed.
  print STDERR "  [Assigning sections to chapters]\n";
  foreach (@Sections, @Notes, Mkdoc::Overload->list) {
    my($chapter) = $chapter{$_->prologue->{Chapter}};
    unless ($chapter) {
      my(%prologue);
      if ($_->prologue->{Chapter} eq 'Notes') {
	$prologue{Description} = "Miscellaneous notes.";
      } elsif ($_->prologue->{Chapter} eq 'Overloaded Definitions') {
	$prologue{Description} = "These objects have multiple definitions.";
      }
      $chapter = Mkdoc::Chapter->new(name=>$_->prologue->{Chapter}, prologue=>\%prologue,
				     sorted=>$Sorted);
      $chapter{$chapter->name} = $chapter;
      push @Chapters, $chapter;
    }
    $chapter->add_members($_);
    $_->up($chapter);
  }

  # Link chapters together
  print STDERR "  [Linking chapters]\n";
  @Chapters = Mkdoc::Chapter->mklinks(sort_chapters 'warn', @Chapters);
  map {$_->up($Top)} @Chapters;

  # Link the sections together in each chapter
  print STDERR "  [Linking sections]\n";
  my($chap_secnum) = 1;
  foreach (@Chapters) {
    $_->secnum($chap_secnum);
    my($sec_secnum) = 1;
    foreach (Mkdoc::Function->mklinks($_->get_members($Sorted))) {
      $_->secnum("$chap_secnum.$sec_secnum");
      $sec_secnum++;
    }
    $chap_secnum++;
  }
}

####################################################################################################
####################################################################################################
#				      M A I N   P R O G R A M
#				        T H I R D   P A S S
####################################################################################################
####################################################################################################
print STDERR "$Name: pass 3: Generating output...\n";

{
  my(@chapter,$chapter);
  push @chapter, toc if $TocLevels>0;
  print STDERR "  [Main Body]\n";
  push @chapter, $CIContent if $CIContent && $CIPosition eq 'begin';
  push @chapter, $PIContent if $PIContent && $PIPosition eq 'begin';
  foreach $chapter (@Chapters) {
    print STDERR "    ", $chapter->name, "\n" if $Verbose;
    push @chapter, $chapter->render($Output,\%ExternalXRefs,@ExcludeTags);
    my(@members,$member) = $chapter->get_members($Sorted);
    foreach $member (@members) {
      print SUMMARY_FILE join "\000", ($member->name, $member->class, $Output->url_of($member),
				       $member->summary);
      print SUMMARY_FILE "\n";
      push @chapter, $member->render($Output,\%ExternalXRefs,@ExcludeTags);
    }
  }
  push @chapter, $CIContent if $CIContent && $CIPosition eq 'end';
  push @chapter, $PIContent if $PIContent && $PIPosition eq 'end';
  $Output->output(@chapter);
}
close SUMMARY_FILE;

# Because the first line of this file looks like a Bourne shell script, we must tell XEmacs
# explicitly that this is really a perl script.
#
# Local Variables:
# mode:perl
# End:
