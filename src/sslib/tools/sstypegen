#!/bin/sh
perl -x -S $0 "$@"
exit
# 4 \
# 5  \
# 6   \
# 7    > These lines are here so line numbers reported by perl will be off by exactly 10 (line
# 8   /  numbers are wrong because of the portable way we're executing this script).
# 9  /
#10 /
#!/usr/bin/perl
use strict;

# Copyright(C) 1999 The Regents of the University of California.
#     This work  was produced, in  part, at the  University of California, Lawrence Livermore National
#     Laboratory    (UC LLNL)  under    contract number   W-7405-ENG-48 (Contract    48)   between the
#     U.S. Department of Energy (DOE) and The Regents of the University of California (University) for
#     the  operation of UC LLNL.  Copyright  is reserved to  the University for purposes of controlled
#     dissemination, commercialization  through formal licensing, or other  disposition under terms of
#     Contract 48; DOE policies, regulations and orders; and U.S. statutes.  The rights of the Federal
#     Government  are reserved under  Contract 48 subject  to the restrictions agreed  upon by DOE and
#     University.
#
# Copyright(C) 1999 Sandia Corporation.
#     Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive license for use of this work
#     on behalf of the U.S. Government.  Export  of this program may require a license from the United
#     States Government.
#
# Disclaimer:
#     This document was  prepared as an account of  work sponsored by an agency  of  the United States
#     Government. Neither the United States  Government nor the United States Department of Energy nor
#     the  University  of  California  nor  Sandia  Corporation nor any  of their employees  makes any
#     warranty, expressed  or  implied, or  assumes   any  legal liability  or responsibility  for the
#     accuracy,  completeness,  or  usefulness  of  any  information, apparatus,  product,  or process
#     disclosed,  or  represents that its  use would   not infringe  privately owned rights. Reference
#     herein  to any  specific commercial  product,  process,  or  service by  trade  name, trademark,
#     manufacturer,  or  otherwise,  does  not   necessarily  constitute  or  imply  its  endorsement,
#     recommendation, or favoring by the  United States Government   or the University of  California.
#     The views and opinions of authors expressed herein do not necessarily state  or reflect those of
#     the  United  States Government or  the   University of California   and shall  not be  used  for
#     advertising or product endorsement purposes.
#
# Authors:
#     Robb P. Matzke              LLNL
#
# Acknowledgements:
#     Mark C. Miller              LLNL - Design input

###############################################################################################################################
## Author:
#   Robb Matzke, LLNL
#
## Purpose:
#   This script scans the C source files mentioned on its command-line looking for typedefs for persistent objects. The output
#   is two source files in the current working directory for each input file. The source file names are generated from the
#   input file by appending `tab' to the file basename: e.g., processing ssscope.h generates ssscopetab.c and ssscopetab.h.
#
###############################################################################################################################

# Stuff for lexical analysis. We convert comments, string literals, and preprocessor directives to things
# that are easier to parse. See &lexize for details.
my %LexIndex;
my $LexIndex=0;

my %PersType;       # Base names (e.g., `field') of all persistent object types in the current source file.
my %AllPersType;    # Base names (e.g., `field') of all persistent object types seen so far, across all files.
my %EnumType;       # Names of enumeration types
my $CurFileBase;    # If the source file name is /foo/ssfile.c then this variable will be set to `file', etc.

# Given the name of the input file, open the input file and create the two output files.
sub open_files {
  my($fname) = @_;

  # Create file names
  my($basename) = $fname =~ /([^\/]+)\.[^\.\/]+$/;
  ($CurFileBase) = $basename =~ /^ss(.*)/;
  my($cname) = $basename . "tab.c";
  my($hname) = $basename . "tab.h";
  print STDERR "processing $fname to produce $cname and $hname\n";

  # Open the files
  open SRC, $fname or die "cannot open $fname: $!\n";
  my $src = join "", <SRC>;
  close SRC;
  open HFILE, ">$hname" or die "cannot create $hname: $!\n";
  open CFILE, ">$cname" or die "cannot create $cname: $!\n";

  # Emit file prologues
  print HFILE "/* This file is machine generated by sstypegen from $fname.  DO NOT MODIFY! */\n";
  print HFILE "#ifndef SS_HAVE_\U$basename\ETAB_H\n";
  print HFILE "#define SS_HAVE_\U$basename\ETAB_H\n";
  print HFILE "\n";

  print CFILE "/* This file is machine generated by sstypegen from $fname.  DO NOT MODIFY! */\n";
  print CFILE "#include \"sslib.h\"\n";
  print CFILE "SS_IF(${CurFileBase}tab);\n";
  print CFILE "\n";

  return $src;
}

# Replacing certain lexical elements with `@<X#>' where `X' is the class designator, in order to make parsing easier.
#   C    = comment
#   P    = preprocessor statement
#   S    = string
# The `#' is a unique number. `@' characters that appear in the original input stream are replaced by `@@' when they appear
# outside one of the lexical elements described above.
sub lexize {
  local($_) = @_;
  my($class);

SW:{
    /^\/\*/            && ($class = "C",  last SW);
    /^\/\//            && return "\n"; # discard C++ comments
    /^[\"\']/          && ($class = "S",  last SW);
    /^\#\s*(define|undef|if|ifdef|ifndef|else|elif|endif|include)\b/ && ($class = "P", last SW);
    die;
  }
  $class = "@<$class" . $LexIndex++ . ">";
  $LexIndex{$class} = $_;
  return $class;
}

# Given a location in $where (m=memory, f=file) and a C datatype, return the corresponding HDF5 datatype.
sub hdf5type {
  my($where,$type) = @_;

  return "H5T_NATIVE_\U$1" if $type =~ /^(int|char|short|long|float|double)$/;
  return "H5T_NATIVE_U\U$1" if $type =~ /^unsigned\s+(int|char|short|long)$/;
  return "H5T_NATIVE_HBOOL" if $type =~ /^hbool_t$/;
  return "H5T_NATIVE_HADDR" if $type =~ /^haddr_t$/;
  return "H5T_NATIVE_HSIZE" if $type =~ /^hsize_t$/;
  return "ss_$1_t$where" if $type =~ /^ss_([a-z]+)_t$/;
  die "sstypegen::hdf5type(where=$where,type=$type)"
}

# Generate the C struct that describes a table element as it exists in memory, transient data and all.
# Also emit forward declarations for the associated HDF5 datatypes.
sub generate_FOOobj_t {
  my($name,@members) = @_;
  my($s);
  my($shortname) = $name =~ /(\w+)obj/;

  $s .= "#define SS_\U${shortname}\E(LNK) ((LNK) && SS_MAGIC(ss_${shortname}_t)==SS_MAGIC_OF(LNK) ? \\\n";
  $s .= "     (ss_${name}_t*)ss_pers_deref((ss_pers_t*)(LNK)) : NULL)\n";
  $s .= "#define SS_\U${shortname}\E_M(LNK,MEMB) (SS_\U${shortname}\E(LNK)->MEMB)\n";
  $s .= "#define SS_\U${shortname}\E_P(LNK,MEMB) (&SS_\U${shortname}\E_M(LNK,MEMB))\n";
  $s .= sprintf "%-40s%s\n", "extern const ss_${shortname}_t SS_\U${shortname}\E_NULL;\n";
  $s .= sprintf "%-40s%s\n", "extern hid_t ss_${name}_tfm;","/* HDF5 equivalent of the C type ss_${name}_tf */";
  $s .= sprintf "%-40s%s\n", "extern hid_t ss_${name}_tff;","/* HDF5 datatype for a row of a table in a file */";
  $s .= sprintf "%-40s%s\n", "extern hid_t ss_${shortname}_tm;","/* HDF5 datatype for $shortname link in memory */";
  $s .= sprintf "%-40s%s\n", "extern hid_t ss_${shortname}_tf;","/* HDF5 datatype for $shortname link in a file */";
  $s .= sprintf "%-40s%s\n", "typedef struct ss_${name}_t {","/* Datatype for object in memory */";
  $s .= sprintf "    %-19s m; %13s/* transient stuff */\n", "ss_${name}_tm", "";
  for my $m (@members) {
    my $tmp;
    if ($m->{indirect}) {
      # Variable length arrays
      die unless $m->{indirect} eq "*"; # only one level of indirection allowed
      $tmp = sprintf "    %-19s %s", "ss_array_t", $m->{member};
    } else {
      $tmp = sprintf "    %-19s %s", $m->{type}, $m->{member};
    }
    $tmp .= join "", map {"[$_]"} split /,/, $m->{array};
    $tmp .= ";";
    $tmp = sprintf "%-40s%s", $tmp, ($LexIndex{$m->{comment}}||"/* $m->{comment} */") if $m->{comment};
    $s .= $tmp . "\n";
  }
  $s .= "} ss_${name}_t;\n";
  $s .= "extern const ss_${name}_t SS_\U${name}\E_ZERO; /*mostly just to get type name into symbol table for debugging*/\n";
  $s .= "\n";
  return $s;
}

# The ss_FOOobj_tfm and ss_FOOobj_tff HDF5 types.  The `tfm' type is the HDF5 datatype for the persistent members
# of the table as they exist in memory and thus is the same size as the generated ss_FOOobj_t type. The `tff' type
# is the HDF5 datatype to use when creating a new table.
sub generate_FOOobj_tf {
  my($name,$where,@members) = @_;
  my($obj_struct) = "ss_${name}_tf$where";
  my($shortname) = $name =~ /(.+)obj$/;
  my($lnk_struct) = "ss_${shortname}_t$where";
  my($cbase) = $where eq 'f' ? "ss_${name}_tf" : "ss_${name}_t"; # not `tm'
  my($pre,$s,@decl,@cleanup,$nerrors);

  push @decl, "hid_t type=-1;";
  push @cleanup, "H5Tclose(type);";

  for my $m (@members) {
    my @mycleanup;

    my $offset = "HOFFSET(ss_${name}_t, $m->{member})";
    $offset = "HOFFSET(ss_${name}_t, $m->{member}\[0])" if $m->{array};

    # The datatype for this member
    my $hdf5type = hdf5type $where, $m->{type};

    # If this is an array then create an hdf5 array type
    if ($m->{array}) {
      my $ndims = split /,/, $m->{array};
      my $n = scalar @decl;
      push @decl, "static hsize_t dims$n\[$ndims] = {$m->{array}};";
      push @decl, "hid_t subtype$n=-1;";
      push @cleanup, "H5Tclose(subtype$n);";
      push @mycleanup, "if (H5Tclose(subtype$n)<0) SS_ERROR(HDF5);";
      $s .= "    subtype$n = H5Tarray_create($hdf5type, $ndims, dims$n, NULL);\n";
      $hdf5type = "subtype$n";
    }

    # If this is a pointer then use SSlib's variable length array datatype.
    if ($m->{indirect}) {
      $hdf5type = "ss_array_t$where";
    }

    # Check for errors
    if (!$hdf5type) {
      print STDERR "  $obj_struct.$m->{member}: base type `$m->{type}' has no corresponding HDF5 type\n";
      $nerrors++;
      next;
    }

    # Generate code for the struct member
    $s .= "    if (H5Tinsert(type, \"$m->{member}\", $offset, $hdf5type)<0)\n";
    $s .= "        SS_ERROR_FMT(HDF5, (\"cannot insert member `$m->{member}' into `$obj_struct'\"));\n";
    $s .= join("\n", map {"    ".$_} @mycleanup)."\n" if @mycleanup;
  }

  $pre .= "\n";
  $pre .= "hid_t $lnk_struct = -1;\n";
  $pre .= "hid_t $obj_struct = -1;\n";
  $pre .= "const ss_${shortname}_t SS_\U${shortname}\E_NULL;\n" if $where eq 'm'; #only needed once
  $pre .= "const ss_${name}_t SS_\U${name}\E_ZERO;\n" if $where eq 'm'; #only needed once
  $pre .= "\n";
  $pre .= "/*DOCUMENTED*/\n";
  $pre .= "static hid_t\n";
  $pre .= "${obj_struct}_create(void)\n";
  $pre .= "{\n";
  $pre .= "    SS_ENTER(${obj_struct}_create, hid_t);\n";
  $pre .= join("\n", map {"    ".$_} @decl) . "\n\n";
  $pre .= "    if ((type=H5Tcreate(H5T_COMPOUND, sizeof(ss_${name}_t)))<0) SS_ERROR(HDF5);\n";

  $s = $pre . $s;
  $s .= "    if (H5Tpack(type)<0) SS_ERROR(HDF5);\n" if $where eq 'f';
  $s .= "    H5Tlock(type);\n";
  $s .= "\n  SS_CLEANUP:\n";
  $s .= join("\n", map {"    ".$_} @cleanup) . "\n\n";
  $s .= "    SS_LEAVE(type);\n";
  $s .= "}\n\n";
  return if $nerrors;
  return $s;
}

# This is the top-level function to call when generating the various datatypes. It can be called from
# a substitution on the datatype itself with $body being all the stuff between the curly braces.  The $name is
# the base name of the type being generated, including the `obj' part (e.g., `fieldobj')
sub generate {
  my($name,$body) = @_;
  my($shortname) = $name =~ /(\w+)obj/; # same as $name but without the trailing `obj'
  my($nerrors,$t,$tfm,$tff,@members);
  print STDERR "parsing table $name...\n";

  # Check whether we've already seen this.
  if ($PersType{$shortname}++) {
    print STDERR "already processed type `$name'\n";
    exit 1;
  }

  # Parse the type
  for my $line (split /\n/, $body) {
    next unless $line =~ /\S/;          # skip blank lines
    next if $line =~ /^\s*@<C\d+>\s*$/; # line contains only a comment
    my($type,$indirect,$member,$array,$comment) =
      $line =~ /^\s+(\w+(?:\s+\w+)*)    # the type names
                (\s+|\s*\*\s*)          # indirection
                (\w+)((?:\[.*?\])*)\s*; # member name (and array)
                \s*(@<C\d+>)?/x;        # comment
    if (!defined $member) {
      $line =~ tr/ \t//s;
      print STDERR "  cannot parse: $line\n";
      return;
    }
    $indirect =~ s/\s//g;
    $type = "unsigned int" if $type eq "unsigned";
    $array =~ s/\]\[/,/g;
    $array =~ s/[\[\]]//g;
    push @members, {type=>$type, indirect=>$indirect, member=>$member, array=>$array, comment=>$comment};
  }

  # Generate various things
  $t = generate_FOOobj_t $name, @members or $nerrors++;
  $tfm = generate_FOOobj_tf $name, 'm', @members or $nerrors++;
  $tff = generate_FOOobj_tf $name, 'f', @members or $nerrors++;

  # Emit the various things if there were no errors
  print HFILE "/*---------- ", uc($name), ' ', '-' x (114-length $name), "*/\n" unless $nerrors;
  print HFILE $t    unless $nerrors;
  print CFILE $tfm  unless $nerrors;
  print CFILE $tff  unless $nerrors;
  return "";
}

# Generate HDF5 datatypes for an enumeration type
sub do_enum {
  my($name,$body) = @_;
  print STDERR "parsing enum $name...\n";
  my $c;

  # Check whether we've already seen this.
  if ($EnumType{$name}++) {
    print STDERR "already processed type `$name'\n";
    exit 1;
  }

  # The function to create the datatype
  $c .= "hid_t ss_${name}_tf, ss_${name}_tm;\n";
  $c .= "\n";
  $c .= "/*DOCUMENTED*/\n";
  $c .= "static hid_t\n";
  $c .= "ss_${name}_tX_create(void)\n";
  $c .= "{\n";
  $c .= "    SS_ENTER(ss_${name}_tX_create, hid_t);\n";
  $c .= "    ss_${name}_t val;\n";
  $c .= "    hid_t basetype=-1, retval=-1;\n\n";
  $c .= "    if ((basetype=H5Tcopy(H5T_NATIVE_INT))<0) SS_ERROR(HDF5);\n";
  $c .= "    if (H5Tset_precision(basetype, 8*sizeof(ss_${name}_t))<0) SS_ERROR(HDF5);\n";
  $c .= "    if (H5Tset_size(basetype, sizeof(ss_${name}_t))<0) SS_ERROR(HDF5);\n";
  $c .= "    if ((retval=H5Tenum_create(basetype))<0) SS_ERROR(HDF5);\n\n";

  # Parse the type
  for my $line (split /\n/, $body) {
    my($member,$comment) = $line =~ /^\s*(\w+),?\s*(@<C\d+>)?/;
    die unless $member;
    $c .= "    val = $member;\n";
    $c .= "    if (H5Tenum_insert(retval, \"$member\", &val)<0) SS_ERROR(HDF5);\n";
  }

  $c .= "\n";
  $c .= "  SS_CLEANUP:\n";
  $c .= "    if (basetype>0) H5Tclose(basetype);\n";
  $c .= "    if (retval>0) H5Tclose(retval);\n";
  $c .= "    SS_LEAVE(retval);\n";
  $c .= "}\n";

  print HFILE "/*---------- ", uc($name), ' ', '-' x (114-length $name), "*/\n";
  printf HFILE "%-40s%s\n", "extern hid_t ss_${name}_tm;", "/* The HDF5 memory datatype for an enumeration type */";
  printf HFILE "%-40s%s\n", "extern hid_t ss_${name}_tf;", "/* The HDF5 file datatype for an enumeration type */";
  print HFILE "\n";
  print CFILE $c;
  return "";
}

# Generate an initialization function for the current file.  This function should initialize all the
# global HDF5 datatype variables that resulted from processing the current source file.
sub initfunc {
  my $s;
  $s .= "/*DOCUMENTED*/\n";
  $s .= "herr_t\n";
  $s .= "ss_${CurFileBase}tab_init(void)\n";
  $s .= "{\n";
  $s .= "    ss_pers_class_t *pcls;\n";
  $s .= "    unsigned seqn;\n";
  $s .= "    SS_ENTER_INIT;\n";
  $s .= "\n";

  $s .= "    /*" . "-" x 120 . "\n";
  $s .= "     *   E N U M E R A T I O N   T Y P E S\n";
  $s .= "     *" . "-" x 120 . "*/\n";
  for my $enum (sort keys %EnumType) {
    $s .= "    /*--- \U$enum\E enum ---*/\n";
    $s .= "    if ((ss_${enum}_tf= ss_${enum}_tm=ss_${enum}_tX_create())<0) SS_ERROR_FMT(INIT,(\"ss_${enum}_t\"));\n";
    $s .= "\n";
  }

  $s .= "    /*" . "-" x 120 . "\n";
  $s .= "     *   P E R S I S T E N T   O B J E C T   L I N K   T Y P E S\n";
  $s .= "     *" . "-" x 120 . "*/\n";
  for my $table (sort keys %PersType) {
    $s .= "    /*--- \U$table\E table ---*/\n";
    $s .= "    seqn = SS_MAGIC_SEQUENCE(SS_MAGIC(ss_${table}_t));\n";
    $s .= "    assert(seqn<SS_PERS_NCLASSES);\n";
    $s .= "    pcls = ss_pers_class_g + seqn;\n";
    $s .= "    if ((pcls->tm = ss_${table}_tm = H5Tcopy(ss_pers_tm))<0) SS_ERROR_FMT(INIT,(\"ss_${table}_tm\"));\n";
    $s .= "    if ((pcls->tf = ss_${table}_tf = H5Tcopy(ss_pers_tf))<0) SS_ERROR_FMT(INIT,(\"ss_${table}_tf\"));\n";
    $s .= "\n";
  }

  $s .= "    /*" . "-" x 120 . "\n";
  $s .= "     *   P E R S I S T E N T   O B J E C T   T A B L E   T Y P E S\n";
  $s .= "     *" . "-" x 120 . "*/\n";
  for my $table (sort keys %PersType) {
    $s .= "    /*--- \U$table\E table ---*/\n";
    $s .= "    seqn = SS_MAGIC_SEQUENCE(SS_MAGIC(ss_${table}_t));\n";
    $s .= "    assert(seqn<SS_PERS_NCLASSES);\n";
    $s .= "    pcls = ss_pers_class_g + seqn;\n";
    $s .= "    pcls->name = \"$table\";\n";
    $s .= "    pcls->t_size = sizeof(ss_${table}obj_t);\n";
    $s .= "    if ((pcls->tfm=ss_${table}obj_tfm=ss_${table}obj_tfm_create())<0) SS_ERROR_FMT(INIT,(\"ss_${table}obj_tfm\"));\n";
    $s .= "    if ((pcls->tff=ss_${table}obj_tff=ss_${table}obj_tff_create())<0) SS_ERROR_FMT(INIT,(\"ss_${table}obj_tff\"));\n";
    $s .= "    if (NULL==(pcls->valinfo = ss_val_compile(pcls->tfm, 0, NULL, &(pcls->valinfo_nused))))\n";
    $s .= "        SS_ERROR_FMT(INIT,(\"ss_${table}obj_tfm\"));\n";
    $s .= "    if (ss_val_ser_type(pcls->valinfo_nused, pcls->valinfo, &(pcls->serialized))<0)\n";
    $s .= "        SS_ERROR_FMT(INIT,(\"ss_${table}obj_tff\"));\n";
    $s .= "\n";
  }

  $s .= "\n  SS_CLEANUP:\n\n";
  $s .= "    SS_LEAVE(0);\n";
  $s .= "}\n\n";
  return $s;
}

# Append final stuff to the files and close them. Names of datatypes defined from the current file are transfered into
# the master list.
sub close_files {
  print HFILE "#endif\n";
  close HFILE;

  print CFILE initfunc;
  close CFILE;

  map {$AllPersType{$_}++} %PersType;
  %PersType = ();
  %EnumType = ();
}

# Create a file that has object link datatypes only.
sub linktypes {
  open LINKTYPES, ">sslinks.h" or die "cannot create sslinks.h: $!\n";
  print LINKTYPES "/* This file is machine generated by sstypegen. */\n";
  print LINKTYPES "#ifndef SS_HAVE_SSLINKS_H\n";
  print LINKTYPES "#define SS_HAVE_SSLINKS_H\n";
  for my $type (sort keys %AllPersType) {
    print LINKTYPES "typedef struct {ss_pers_t pers;} ss_${type}_t;\n";
  }
  print LINKTYPES "#endif /*!SS_HAVE_SSLINKS_H*/\n";
  close LINKTYPES;
}

# The main body of this script.....  Load each source file specified on the command line, convert hard-to-parse things
# link strings, comments, and preprocessor directives into single tokens of the form /@<[CPS]\d+>/, then look for certain
# typedefs and invoke the &generate function on them.
for my $srcfile (@ARGV) {
  my $src = open_files $srcfile;

  # Convert comments and strings into more parsable things. Both have to be converted simultaneously.
  $src =~ s/(  # Comments
	       (\/\*.*?\*\/)
	     | # Discard C++ comments
	       (\/\/.*?\n)
	     | # Strings, single or double quotes
	       (([\"\'])(\\.|[^\5])*?\5)
	    )/lexize $1/segx;

  # Convert preprocessor directives into something more parsable.
  $src =~ s/(  # Preprocessor statements may continue across lines
               (^\#([^\n]*\\\n)*[^\n]*)
	    )/lexize $1/megx;

  # Convert bare `@' characters so they don't interfere with the new tokens we introduced above.
  $src =~ s/@(?!<)/@@/g;

  # Process each enum definition
  $src =~ s/^typedef\s+enum\s+ss_(\w+)_t\s*\{\s*(?:@<C\d+>)?\n # the `typedef enum' line
            ((^\s+([A-Z_0-9]+),?\s*(@<C\d+>)?\s*\n)+)          # body lines of the type
            ^\}\s*ss_\1_t\s*;                                  # closing line
           /do_enum $1, $2/xmeg;

  # Process each table type definition
  $src =~ s/^typedef\s+struct\s+ss_(\w+obj)_tf\s*\{\s*(?:@<C\d+>)?\n # the `typedef struct' line
            ((^\s+.*?;\s*(@<C\d+>)?\s*\n)+)                          # body lines of the type
            ^\}\s*ss_\1_tf\s*;                                       # closing line
           /generate $1, $2/xmeg;

  close_files;
}
linktypes;


# Because the first line of this file looks like a Bourne shell script, we must tell XEmacs
# explicitly that this is really a perl script.
#
# Local Variables:
# mode:perl
# End:
