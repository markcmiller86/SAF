\input texinfo
@c %**start of header
@setfilename saf.info
@settitle SAF Software Suite Configuration and Building
@setchapternewpage off
@paragraphindent 0
@c %**end of header
@c STATIC COPYRIGHT NOTICE

@c Summary Description and Copyright
@ifinfo
This documentation describtes two things: how to configure and build
components of the SAF software suite and how the configuration process works
(i.e., how maintainers of SAF software can modify its behavior).

Copyright 1999 Regents of the University of California
@end ifinfo


@c Title and Copyright
@titlepage
@title SAF Software Suite
@subtitle Configuration and Building
@author Robb Matzke
Copyright @copyright{} 1999 Regents of the University of California
@end titlepage

@c Top Node and Master Menu
@node Top
@top SAF Software Suite: Configuration and Building
The Data Models and Formats (SAF) Subcommittee of the Scientific Data Models
(SDM) Committee of the Accelerated Strategic Computing Initiative (ASCI)
distributes a collection of software known as the SAF software suite. This
collection consists of a SAF application programming interface (the
@samp{safapi}), a mathematics package called the vector bundle tables (the
@samp{vbt}), and a data portability package (the @samp{dsl}). Additional
packages may be added in the future.

This documentation describes how to configure, build, test, and install all or
part of the SAF software suite and how the entire configuration subsystem
works.

@menu
* Installation::                
* Development::                 
* Frequently Asked Questions::  
@end menu

@c ============================================================================
@c ============================================================================
@node Installation
@chapter Installation

This section describes how one installs the libraries, header files,
and tools of the SAF software suite.

@menu
* Obtaining the Software::      
* Unpacking the Software::      
* Configuration::               
* Building::                    
* Testing::                     
* Installing::                  
@end menu

@c ============================================================================
@node Obtaining the Software
@section Obtaining the Software

[Not written yet.]

@c ============================================================================
@node Unpacking the Software
@section Unpacking the Software

The SAF software suite is distributed as a compressed @code{tar} file which
will expand into a directory named like @file{saf-1.0}. This directory will
contain top-level configuration and documentation and each of the other
packages will appear as a subdirectory.

@example
$ gunzip <saf-1.0 |tar xf -
$ cd saf-1.0
@end example

@table @file
@item Dependencies
A file listing the dependencies for the object files whose source files
are in this directory.  All directories have this file although it's
empty when the directory doesn't contain any source files.

@item Makefile.in
The input files that @code{configure} uses to generate each
@file{Makefile}. Each directory has one of these files.

@item README
Instructions for obtaining further instructions.

@item acconfig.h
List of potential features available in C source code. The actual list
of features will be generated by @code{configure} and placed in the
@file{include/SAFconfig.h} file.

@item aclocal.m4
Macros that @code{m4} uses to detect how to build shared libraries.

@item config
A directory of configuration-related files.

@item configure
The main configuration shell script.

@item configure.in
The input used to generate the @file{configure} script.

@item safapi
The SAF API package.

@item doc
Top-level documentation. Each package may also have its own
documentation.

@item dsl
The DSL package.

@item include
Header files needed to compile various packages. Most of these are
symlinks to the real header file in the package that defines it.

@item vbt
The VBT package.
@end table

@c ============================================================================
@node Configuration
@section Configuration

All SAF software packages can be compiled either within the source tree or in
separate directories. The directory hierarchy where the SAF source code is
located is called the @dfn{source tree} and the directory hierarchy where SAF
software is built is called the @dfn{build tree}. Some advantages of using a
build tree separate from the source tree are that the source tree is not
polluted with generated files, a failed build attempt can be easily cleaned up
by removing the entire build tree, and numerous configurations of SAF can be
compiling simultaneously (such as serial and parallel, debug and production
versions).

To configure SAF software the user should create a build directory (if other
than the root of the SAF source tree) and @code{cd} into that directory. Most
users can simply run @code{configure} at this point in order to detect
characteristics of the host and compiler and generate the makefiles. However,
the behavior of @code{configure} can be influenced with various environment
variables and command-line switches:

Example: the source tree is @file{/usr/src/saf-1.0} and the build tree is
@file{/tmp/build/saf-1.0/plain}.

@example
$ mkdir -p /tmp/build/saf-1.0/plain
$ cd /tmp/build/saf-1.0/plain
$ CC=mpicc CPPFLAGS=-I$HOME/include LDFLAGS=-L$HOME/lib \
  /usr/src/saf-1.0/configure --enable-production
@end example

Some users like to create a shell script in the root of the source tree 
so they don't have to remember all the environment variables and
switches. An example is a shell script called @file{config.robb} which
the author uses:

@example
#!/bin/sh

# Configure is in the same directory as this script.
configure=`echo $0 |sed s/config.robb/configure/`

env \
    CPPFLAGS="$CPPFLAGS -I$HOME/include" \
    LDFLAGS="$LDFLAGS -L$HOME/lib" \
    $configure --prefix=$HOME "$@@"
@end example


@menu
* Environment Variables::       
* Configure Switches::          
@end menu

@c ----------------------------------------------------------------------------
@node Environment Variables
@subsection Environment Variables

These environment variables affect the behavior of @code{configure}:

@table @code
@item CC
The name of the C compiler. The default is @code{cc} or, preferably,
@code{gcc}. If the compiler base name is @code{mpicc} or @code{mpcc} then
parallel versions of all SAF software will be created (there are other ways to
specify a parallel library when a C compiler wrapper is not available).

@example
$ CC=/usr/local/mpich/bin/mpicc ./configure
$ CC='cc -n32' ./configure
@end example

@item CFLAGS
This variable contains the command-line switches which will be passed to the C
compiler. Any value specified here will be augmented with additional switches
detected during the configuration process.

@example
$ CFLAGS=-fullwarn ./configure
@end example

@item CPPFLAGS
These are the command-line switches for the C preprocessor and will be
supplied to the C compiler in addition to the @code{$CFLAGS} value when
compiling a C source file into an object file.

@example
$ CPPFLAGS="-DNDEBUG -I/usr/ncsa/include" ./configure
@end example

@item LDFLAGS
These are the flags to pass to the linker (via the compiler) in addition to
the flags determined by @code{configure}.

@example
$ LDFLAGS=-L/usr/ncsa/lib ./configure
@end example


@item MAKE
The name of the @code{make} command, defaulting to @code{make}. All common
versions of Unix @code{make} are supported although certain versions have
crippled functionality (for instance, Irix @code{make} is unable to build SAF
software when the build tree is other than the source tree, but Irix
@code{pmake} is fully supported).  Obviously, if a value other than
@code{make} is specified then the specified version of make must be used to
build the software.

@item TEST_FILE_PATH
This is the name of a directory where the test suite will create its test files. The default is @file{.}, meaning that each test file will be created in the same directory as the test program.

@example
$ MAKE=gmake ./configure
$ gmake
@end example
@end table

@c ----------------------------------------------------------------------------
@node Configure Switches
@subsection Configure Switches

These @code{configure} switches affect how things are detected:

@table @code
@item --prefix=@var{prefix}
Building the software suite results in headers, libraries, and tools which are
initially created in the build tree. Issuing the @code{make install} command
will copy these public files to directories named @file{include}, @file{lib},
and @file{bin} under the @var{prefix} directory, which must already exist. The
default prefix is @file{/usr/local}.  @b{The prefix should not be an
existing directory in the build or source tree.} Note: shared libraries must
generally be installed before they can be used.

@example
$ ./configure --prefix=$HOME
@end example

@item --enable-production
All source code is compiled for debugging by default (no optimizations and the
@samp{-g} compiler flag specified). Giving this switch will cause symbolic
debugging to be disabled and full optimizations turned on. It is also possible
to configure all software for profiling by saying
@code{--enable-production=profile}.

@item --with-zlib=@var{incdir},@var{libdir}
@itemx --without-zlib
If HDF5 is one of the packages distributed with the SAF software (as opposed
to being already installed on the system) then this switch can be used to
indicate where the ZLIB headers and library are located if they're in a
nonstandard location. Alternatively, saying @code{--without-zlib} will prevent
HDF5 from using it even when it's installed on the system (so applications
don't have to link with @code{-lz}).

@item --enable-shared
If this switch is supplied then the makefiles will be set up to generate both
static and shared libraries. Shared libraries have not been tested extensively
and some systems are unable to link an executable against multiple shared
libraries unless the libraries have been installed in their final home with
@code{make install}.

@item --enable-parallel=@var{style}
Normally a parallel library is built if the @code{CC} environment variable
contains a name recognized as a parallel compiler. However, if such a compiler
is unavailable then one may turn on the parallel features of the library by
supplying this option. The only currently valid @var{style} is @samp{mpich}.

The following two commands are equivalent:
@example
$ CC=mpicc ./configure
$ ./configure --enable-parallel=mpich
@end example

@item --help
This switch will print @code{configure} usage information.

@end table

@c ============================================================================
@node Building
@section Building

The public header files, libraries, tools, and test suite are built by
going to the top of the build tree and saying @code{make}@footnote{If
the @code{MAKE} environment variable had a value during the
@code{configure} step then be sure to use that command instead of
@code{make}. This applies to all places where the @code{make} command
is used in this documentation.}. The included packages will be built
from the bottom up and the build will immediately fail if anything goes
wrong.

Individual packages can be compiled by changing directories into the package
(or the package's @file{lib}, @file{test}, or @file{tools} directories) and
saying @code{make} at that point.

@c ============================================================================
@node Testing
@section Testing

The entire test suite can be run by going to the top of the build tree and
issuing the @code{make check} command. Individual packages may be tested by
entering the appropriate directory and issuing the @code{make check} command
there. The test suite will immediately fail if any particular test
fails.

@c ============================================================================
@node Installing
@section Installing

Although the header files and static libraries can be used directly from the
build tree, it is usually more conventient to install them in a common
location. In fact, some systems require that the shared libraries be installed
before being used.

The @code{make install} command will install the public headers, libraries,
and tools of the build tree and can be issued in a subdirectory to install
only that subdirectory and its descendents.

The headers are installed in @file{@var{prefix}/include}, the libraries in
@file{@var{prefix}/lib}, and the tools in @file{@var{prefix}/bin}. The
@var{prefix} is either @file{/usr/local} or the value specified for the 
@code{--prefix} @code{configure} switch.

@c ============================================================================
@c ============================================================================
@node Development
@chapter Development

This chapter describes how the configuration system works, how it can be used
by developers of SAF software, and how it can be extended.

@menu
* Overview::                    
* Make Targets::                
* The Makefile.in Files::       
* Feature Testing::             
@end menu

@c ============================================================================
@node Overview
@section Overview

The SAF software suite uses GNU @code{autoconf}, which has two halves.The
first half runs on a system with the @code{autoconf} tools and generates a
portable Bourne shell script called @code{configure} and a pre-header file
called @file{include/SAFconfig.h.in} which contains the list of potential
features.  Input files to this phase are @file{configure.in} which contains
most of the specialization, @file{aclocal.m4} which contains various functions 
including code to detect how to build shared libraries, and @file{acconfig.h}
which contains C preprocessor definitions for potential features which are not 
detected automatically by configure.

The commands @code{autoheader} and @code{autoconf} are run without arguments
in the top of the source tree (the directory which contains the input files).
The graphs below append an asterisk to indicate executable scripts and bracket
generated files.

Files used in preparing a software package for distribution:

@example
configure.in aclocal.m4 acconfig.h
     |            |          |
     `------------+----------'
                  |
         .--------+------.
         |               |
         v               v
   [configure*]  [SAFconfig.h.in]
@end example

The build host does not need the GNU autoconf tools. It runs the portable (but 
nearly unreadable) @code{configure} script which generates three files:
@file{config.cache} caches the results from run to run, @file{config.log}
contains information about things that failed, and @file{config.status} is a
shell script. The final action of @code{configure} is to run
@code{config.status}, which creates the build tree (if it doesn't exist) and
populates it by creating a @file{Makefile} in each build directory that had a
@file{Makefile.in} in the corresponding source directory. The
@code{config.status} also creates/updates the @file{include/SAFconfig.h} file
which is included by all SAF packages and contains the results of the
configuration.

Files used in configuring a software package:

@example
[configure*]
     |
     |               [SAFconfig.h.in]  Makefile.in
     |                       |              |
     +---------------.       `-------+------'
     |               +---------.     |
     v               v         v     v
[config.cache]  [config.log]  [config.status*]
                                     |
                              .------+------.
                              |             |
                              v             v
                        [SAFconfig.h]    [Makefile]
@end example

In order to reconfigure with different environment variables and/or
switches it's necessary to remove the @file{config.cache} file first.

@c ============================================================================
@node Make Targets
@section Make Targets

The following targets are understood in all directories that
contain a makefile:

@table @code
@item all
This is the default if no target is supplied and results in
building all libraries, test cases, and tools.

@item tests
@itemx tests_here
This target builds all libraries, tools, and test cases (because
the test cases depend on the libraries and tools). The
@code{tests_here} target is not recursive.

@item _tools
@itemx _tools_here
This target builds all libraries and tools, but not test
cases.@footnote{The leading underscore is because tools are in a
directory named @file{tools} and some brain-dead versions of
@code{make} refuse to believe that a target might be something
other than a file or directory.} The @code{_tools_here} target is
not recursive.

@item libs
@itemx libs_here
This target builds all libraries, public and private, but neither test
cases nor tools. The @code{libs_here} target is not recursive.

@item check
@itemx check_here
This target builds everything and then runs the test suite.  The
@code{check_here} target is not recursive.

@item install
This target builds everything and then installs the public headers, 
libraries, and tools in the subdirectories @file{include}, @file{lib}, 
and @file{bin} of the @var{prefix} directory specified to
@code{configure} with the @code{--prefix=} switch.

@item uninstall
This targets removes all public headers, libraries, and tools that
were installed by @code{make install}.

@item mostlyclean
This target removes temporary files without removing final
targets. That is, it removes things like object files but not
libraries or executables.

@item clean
This target removes everything that @code{mostlyclean} removes,
plus it removes libraries, test cases, tools, dependency
information, and core dumps.

@item distclean
This target removes everything that @code{clean} removes, plus it
removes all files which were generated on the local system. In
other words, the source tree should look pretty much like it did
when it was first unpacked.

@item maintainer-clean
This target removes everything that @code{distclean} removes, plus
it removes all files which are generated from other
files. Regenerating the necessary files for building may require
special tools (such as @code{autoconf}).

@item dep
@itemx depend
@itemx dep_here
@itemx depend_here
These targets update dependency information for object files. These 
shouldn't have to be run often and never need to be run on GNU
systems.

@item Makefile
This target updates the @file{Makefile} itself, which depends on
things like the @file{Makefile.in} and @file{configure.in}. This
target need not be invoked explicitly when using GNU @code{make}.
@end table

Generally speaking, any of these targets can be invoked from any
directory and the recursive versions will recurse into subdirectories.


@c ============================================================================
@node The Makefile.in Files
@section The Makefile.in Files

Each source directory should have a @file{Makefile.in} from which the
@file{Makefile} will be generated. The @file{Makefile.in} files are intended
to be as simple as possible for the common case and understand three types of
objects: libraries, tests, and tools.

Each @file{Makefile.in} should begin with

@example
top_srcdir=@@top_srcdir@@
top_builddir=.
srcdir=@@srcdir@@
@@COMMENCE@@
@end example

and end with

@example
@@CONCLUDE@@
@end example

The @samp{top_builddir} line should contain the relative path name to the top
of the build tree. If the @file{Makefile.in} appears in the subdirectory
@file{dsl/lib/datasets} then the @samp{top_builddir} value should be
@samp{../../..}.

Comments in the @file{Makefile.in} should begin with a double hash (@samp{##}) 
to prevent them from being interpretted by versions of @code{make} that
understand C preprocessor-like directives.

Generally speaking, the @code{@@COMMENCE@@} line will be substituted
with macro definitions and the @code{@@CONCLUDE@@} line will be
substituted with rules.

@menu
* Recursion::                   
* Public Header Files::         
* Libraries::                   
* Test Suite::                  
* Tools::                       
* Cleanup::                     
@end menu

@c ----------------------------------------------------------------------------
@node Recursion
@subsection Recursion

If a @file{Makefile.in} must recurse into subdirectories then those
subdirectories should be listed in the order of recursion as the value of the
@code{SUBDIRS} macro. The recursion is in depth-first, postfix order, but
certain targets such as @code{clean} will recurse opposite the listed order.

@example
SUBDIRS=lib test tools
@end example

@c ----------------------------------------------------------------------------
@node Public Header Files
@subsection Public Header Files

Each @file{Makefile.in} must be told which header files are public so that it
knows which to install for the @code{make install} target. This is done by
listing the files as the value of the @code{PUB_HDR} macro.

@example
PUB_HDR=saf.h safP.h error.h
@end example

By default, no header files are installed.

@c ----------------------------------------------------------------------------
@node Libraries
@subsection Libraries

Any @file{Makefile.in} may define a single library which depends on source
files in that directory and below. It does so by giving a library name
(without a path) as the value of the @code{LIB} macro. Library names in the
makefiles always end with the @samp{.la} extension since they represent both
static and shared libraries.

The library's source and object files are listed in the
@code{LIB_SRC} macro which can appear in the same
@file{Makefile.in} as the @code{LIB} macro or in @file{Makefile.in}
files in child directories (the child directories should not define
the @code{LIB} macro).

@example
LIB=libsafapi.la
LIB_SRC=cat.c coll.c db.c error.c field.c file.c ftempl.c init.c \
	props.c rel.c seq.c set.c state.c stempl.c utils.c
@end example

Shared libraries must know what other shared libraries they depend on, and
this is specified with the @code{LDFLAGS} and @code{LIBS} macros. By default,
these macros include only non-SAF libraries, but they can be overridden in the 
@file{Makefile.in} by replacing them with values from @code{configure}.  For
instance, the @file{safapi/lib/Makefile.in} contains:

@example
LIBS=@@SAFAPI_LIBS@@
LDFLAGS=@@SAFAPI_LDFLAGS@@
@end example

The @code{@var{PKG}_LIBS} and @code{@var{PKG}_LDFLAGS} contain the switches
required to build shared libraries of package @var{PKG}.

A complete example is the @file{safapi/lib/Makefile.in}:

@example
## SAFAPI library Makefile(.in)
##
## Copyright (C) 1999 Regents of the University of California
##                    All rights reserved.
##
## 
top_srcdir=@@top_srcdir@@
top_builddir=../..
srcdir=@@srcdir@@
@@COMMENCE@@

# The header files and library to install
PUB_HDR=saf.h safP.h error.h
LIB=libsafapi.la
LIB_SRC= cat.c coll.c db.c error.c field.c file.c ftempl.c init.c \
	 props.c rel.c seq.c set.c state.c stempl.c utils.c

# Override these because libsafapi depends on other SAF libraries
LIBS=@@SAFAPI_LIBS@@
LDFLAGS=@@SAFAPI_LDFLAGS@@

@@CONCLUDE@@
@end example

@c ----------------------------------------------------------------------------
@node Test Suite
@subsection Test Suite

The test suite is contained under the @file{test} directory for each
package.@footnote{The actual directory name is arbitrary but certain names,
like @file{tests}, are bad choices because they conflict with targets in the
makefile and some versions of @code{make} are brain-dead enough that it's
impossible to make that work properly.}

Each @file{Makefile.in} may contain any number of test cases, each of which
has its source code located in the same directory. As with libraries, the test 
cases can be distributed among various directories and the tests will be
executed in a depth-first, postfix order. If any test case fails then the
entire make target immediately fails, so tests should be ordered within a
directory from simplest to most complex.

The @code{TESTS} macro lists the names of each of the test programs in
run order and the @code{TEST_SRC} and @code{TEST_OBJ} macros contain the
entire list of test source code and object files. Generally one will list the
source files explicitly and use pattern replacement to generate the list of
object files, which should all end with the @samp{.lo} extension@footnote{The
@samp{.lo} extension is to remind us that they refer to both static and shared 
object files.}.

@example
TEST_SRC=db1.c db2.c
TEST_OBJ=$(TEST_SRC:.c=.lo)
TESTS=$(TEST_SRC:.c=)

$(TESTS): ../../lib/libsafapi.la

db1: db1.lo
	@@$(LT_LINK_EXE) $(CFLAGS) -o $@@ db1.lo ../../lib/libsafapi.la \
	    @@SAFAPI_LDFLAGS@@ @@SAFAPI_LIBS@@

db2: db2.lo
	@@$(LT_LINK_EXE) $(CFLAGS) -o $@@ db2.lo ../../lib/libsafapi.la \
	    @@SAFAPI_LDFLAGS@@ @@SAFAPI_LIBS@@
@end example

As with linking libraries, the @var{PKG}@code{_LDFLAGS} and
@var{PKG}@code{_LIBS} contain the linker switches necessary to link 
any application at the @var{PKG} level except for the libraries at
the @var{PKG} level itself (which is why @file{libsafapi.la} is
explicit).

The fourth line of the example indicates that all test programs
depend on the safapi library, which causes them to be relinked if
the library has been updated. Although we would like to relink
tests if some other library was updated, we're unable to because we
don't know where those libraries are located (they could be part of
the SAF software suite or they might already be installed on the
system).@footnote{We plan to fix this.}

@c ----------------------------------------------------------------------------
@node Tools
@subsection Tools

Describing how to build tools is almost identical to describing how 
to build the test suite. The difference is that the tools appear in 
the @code{tools} directory and the different macros are used in the 
@file{Makefile.in} to describe them. An example from the DSL
package demonstrates this:

@example
TOOLS=vbtgen
TOOL_SRC=expr.c gen.c genc.c genh.c lexer.c parser.c preproc.c \
         support.c tables.c types.c vbtgen.c
TOOL_OBJ=$(TOOL_SRC:.c=.lo)

## The executables all depend on the dsl library, which in turn depends
## on hdf5, mpio, mpi, z, lm, c, ... Unfortunately we don't know where
## any of these others are, so the best we can do is to depend only on
## dsl.
$(TOOLS): ../../lib/libdsl.la

vbtgen: $(TOOL_OBJ)
	@@$(LT_LINK_EXE) $(CFLAGS) -o $@@ $(TOOL_OBJ)
@end example

This particular case is a directory that contains only one tool,
although a directory in general may contain many tools. Also,
@code{vbtgen} doesn't use any special libraries -- a tool that uses 
libraries would do so in a manner similar to the test cases.

@c ----------------------------------------------------------------------------
@node Cleanup
@subsection Cleanup

Each cleanup target has its own macro which lists additional files
to be removed. The macro has the same name as the target except all 
upper case. For instance, if @code{make clean} is to remove files
called @file{gen1.out} and @file{gen2.out} then those names are
listed as:

@example
CLEAN=gen1.out gen2.out
@end example

@b{Do not use wildcards to generate a file list.}

@c ============================================================================
@node Feature Testing
@section Feature Testing

The @file{include/SAFconfig.h} file contains information about what
features were detected by @code{configure}.  Each feature contains a
comment that describes its purpose.

@c ============================================================================
@c ============================================================================
@node Frequently Asked Questions
@chapter Frequently Asked Questions

@menu
* Infinite loops during make::  
* Library not Rebuilt::         
* Debugging Shared Libraries::  
@end menu

@c ============================================================================
@node Infinite loops during make
@section Infinite loops during make

@b{Question:} The @code{make} commands all enter an infinite loop that seems
to be running @code{autoheader} and/or @code{autoconf} and those commands are
failing. What is the problem and what can I do to avoid it?

@b{Answer:} One of the developers probably updated the @file{configure.in}
file and failed to run @code{autoheader} and/or @code{autoconf} to regenerate
the @file{configure} script.  There are a number of ways to work around this:

@enumerate
@item
Use something other than GNU @code{make}. The GNU @code{make} program is smart 
enough to realize that the @file{Makefile} depends on other things and
attempts to rebuilt it when out of date. Since you don't have GNU
@code{autoconf} tools installed on your system (and you shouldn't normally
need them) the update of the @file{Makefile} fails and the original
@file{Makefile} is reused, resulting in an infinite loop.

@item
Edit the @file{config/commence.in} and remove the @code{Makefile} target near
the end of that file. Then run @code{config.status} (or @code{configure} again 
with same arguments) to regenerate all the makefiles.

@item
Touch the @file{configure} script to make it more recent than the files on
which it depends.
@end enumerate

@c ============================================================================
@node Library not Rebuilt
@section Library not Rebuilt

@b{Question:} If I modify one of the DSL source files and then say @code{make}
the @file{*.lo} file is rebuilt but the @file{libdsl} is not rebuilt. Why?

@b{Answer:} The source files for DSL reside one directory level below the
library. The makefiles at the source level do not understand how to add their
objects to the library because it may not be possible to build a shared
library incrementally during a parallel compile. To build the library run
@code{make} in the libraries directory (@file{dsl/lib} in this case) or above.

@c ============================================================================
@node Debugging Shared Libraries
@section Debugging Shared Libraries

@b{Question:} How do I debug the SAF test suite or tools when they're linked
against shared versions of SAF libraries? The executables are all shell
scripts that invoke the executable in some complicated manner.

@b{Answer:} Install the libraries and tools to a temporary location, then
debug them. The shell script wrappers are necessary in order to load programs
that rely on shared libraries that are not yet installed, and most systems
require a fair amount of work in order to accomplish this.  When debugging the 
test suite (which isn't normally installed) it's easiest to change the
@file{Makefile} to install the test suite (or relink the test suite manually
against the installed libraries).

But the best method is to debug against the static libraries and then test the 
shared libraries when all debugging is finished. The behavior of the shared
libraries should be the same as for static libraries since they're built at
the same time, with the same configuration flags, and contain the same
objects.

@c Indices and Table of Contents
@contents
@bye
