/*
 * Copyright(C) 1999-2005 The Regents of the University of California.
 *     This work  was produced, in  part, at the  University of California, Lawrence Livermore National
 *     Laboratory    (UC LLNL)  under    contract number   W-7405-ENG-48 (Contract    48)   between the
 *     U.S. Department of Energy (DOE) and The Regents of the University of California (University) for
 *     the  operation of UC LLNL.  Copyright  is reserved to  the University for purposes of controlled
 *     dissemination, commercialization  through formal licensing, or other  disposition under terms of
 *     Contract 48; DOE policies, regulations and orders; and U.S. statutes.  The rights of the Federal
 *     Government  are reserved under  Contract 48 subject  to the restrictions agreed  upon by DOE and
 *     University.
 * 
 * Copyright(C) 1999-2005 Sandia Corporation.  
 *     Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive license for use of this work
 *     on behalf of the U.S. Government.  Export  of this program may require a license from the United
 *     States Government.
 * 
 * Disclaimer:
 *     This document was  prepared as an account of  work sponsored by an agency  of  the United States
 *     Government. Neither the United States  Government nor the United States Department of Energy nor
 *     the  University  of  California  nor  Sandia  Corporation nor any  of their employees  makes any
 *     warranty, expressed  or  implied, or  assumes   any  legal liability  or responsibility  for the
 *     accuracy,  completeness,  or  usefulness  of  any  information, apparatus,  product,  or process
 *     disclosed,  or  represents that its  use would   not infringe  privately owned rights. Reference
 *     herein  to any  specific commercial  product,  process,  or  service by  trade  name, trademark,
 *     manufacturer,  or  otherwise,  does  not   necessarily  constitute  or  imply  its  endorsement,
 *     recommendation, or favoring by the  United States Government   or the University of  California.
 *     The views and opinions of authors expressed herein do not necessarily state  or reflect those of
 *     the  United  States Government or  the   University of California   and shall  not be  used  for
 *     advertising or product endorsement purposes.
 * 
 * 
 * Active Developers:
 *     Peter K. Espen              SNL
 *     Eric A. Illescas            SNL
 *     Jake S. Jones               SNL
 *     Robb P. Matzke              LLNL
 *     Greg Sjaardema              SNL
 * 
 * Inactive Developers:
 *     William J. Arrighi          LLNL
 *     Ray T. Hitt                 SNL
 *     Mark C. Miller              LLNL
 *     Matthew O'Brien             LLNL
 *     James F. Reus               LLNL
 *     Larry A. Schoof             SNL
 * 
 * Acknowledgements:
 *     Marty L. Barnaby            SNL - Red parallel perf. study/tuning
 *     David M. Butler             LPS - Data model design/implementation Spec.
 *     Albert K. Cheng             NCSA - Parallel HDF5 support
 *     Nancy Collins               IBM - Alpha/Beta user
 *     Linnea M. Cook              LLNL - Management advocate
 *     Michael J. Folk             NCSA - Management advocate 
 *     Richard M. Hedges           LLNL - Blue-Pacific parallel perf. study/tuning 
 *     Wilbur R. Johnson           SNL - Early developer
 *     Quincey Koziol              NCSA - Serial HDF5 Support 
 *     Celeste M. Matarazzo        LLNL - Management advocate
 *     Tyce T. McLarty             LLNL - parallel perf. study/tuning
 *     Tom H. Robey                SNL - Early developer
 *     Reinhard W. Stotzer         SNL - Early developer
 *     Judy Sturtevant             SNL - Red parallel perf. study/tuning 
 *     Robert K. Yates             LLNL - Blue-Pacific parallel perf. study/tuning
 * 
 */
#include <saf.h>
#include <../test/testutil.h>

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Description: This program implements the N to 1 remapping portion of the parallel use case.  It exercises 
 *              the remapping of both fields and topologies.  It only works with a specific saf database
 *              and is not a program that could be used as a general remapping tool, although it could be
 *              used as a starting point to implement such a tool.  The reason that the program was not made
 *              general was so that it could verify the data being remapped.  Writing a program that would have
 *              implemented a general remapping and verify the remap would not have been worth the effort.
 *
 *              The use case works with the file generated by exo_par_wt.c, currently "exo_par_wt.saf".  It
 *              is assumed to exist in the directory TEST_FILE_PATH, defined in "saf.h".  If the file is
 *              located somewhere else then the macro should be redefined.
 *
 *              The specific remappings that are performed are:
 *
 *              Field remappings
 *
 *                     FIELD              SET/COLLECTION
 *
 *                     coords_on_top      TOP_SET/nodes
 *                     disp_on_top        TOP_SET/nodes
 *                     vel_on_top         TOP_SET/nodes
 *                     stress_on_blk2     BLOCK_2/elems
 *                     stress_on_blk5     BLOCK_5/elems
 *                     strain_on_blk1     BLOCK_1/elems
 *                     strain_on_blk3     BLOCK_3/elems
 *                     press_on_blk1      BLOCK_1/elems
 *                     press_on_blk2      BLOCK_2/elems
 *                     cent_on_top        TOP_SET/elems  (2 levels of indirection)
 *                     elem_ids_on_top    TOP_SET/elems
 *
 *              Topology remappings
 *
 *                     DOMAIN COLLECTION  RANGE COLLECTION
 *
 *                     BLOCK_1/elems      TOP_SET/nodes
 *                     BLOCK_2/elems      TOP_SET/nodes
 *                     BLOCK_3/elems      TOP_SET/nodes
 *                     BLOCK_4/elems      TOP_SET/nodes
 *                     BLOCK_5/elems      TOP_SET/nodes
 *
 *              The program contains the expected results from the various saf_read_XXX calls in global
 *              arrays defined near the top of the file.
 *
 *              The program get the names of all the fields that it remappes through the INIT_SUITE and
 *              TIME_SUITE suites.
 *---------------------------------------------------------------------------------------------------------------------------------
 */
#define NUMBERS_PER_LINE 15

/* Global arrays with the expected results from the saf_read_XXX calls. */
float coords_on_top_buf[45] = {0., 1., 2., 0., 1., 2., 0., 1., 2.,
                               0., 1., 0., 1., 0., 1., 0., 0., 0.,
                               0., 0., 0., 0., 0., 0., 1., 1., 1.,
                               1., 1., 1., 0., 0., 0., 1., 1., 1.,
                               2., 2., 2., 2., 2., 0., 0., 1., 1.};
float disp_on_top_s0_buf[45] = {0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
                                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
                                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
float disp_on_top_s1_buf[45] = {1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12, 1.13, 1.14,
                                2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 2.10, 2.11, 2.12, 2.13, 2.14,
                                3.0, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11, 3.12, 3.13, 3.14};
float vel_on_top_s0_buf[45] = { 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
                                0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
                                0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.};
float vel_on_top_s1_buf[45] = {10.0, 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9, 10.10, 10.11, 10.12, 10.13, 10.14,
                               20.0, 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8, 20.9, 20.10, 20.11, 20.12, 20.13, 20.14,
                               30.0, 30.1, 30.2, 30.3, 30.4, 30.5, 30.6, 30.7, 30.8, 30.9, 30.10, 30.11, 30.12, 30.13, 30.14};
int elem_ids_on_top_s0_buf[12] = {100, 101, 102, 103, 104, 105, 106, 207, 208, 209, 210, 211};
int elem_ids_on_top_s1_buf[12] = {100, 101, 102, 103, 104, 105, 106, 207, 208, 209, 210, 211};
float cent_on_top_s0_buf[36] = {0.5,  0.5,  0.5,  0.5, 1.67, 1.33, 1.33, 1.67, 1.33, 1.33, 1.5 , 1.5 ,
                                0. ,  0. ,  0.5,  0.5, 0.  , 0.  , 0.  , 0.  , 0.33, 0.33, 0.25, 0.25,
                                1.5,  0.5,  1.5,  0.5, 1.67, 1.33,  .67, 0.33, 0.67, 1.33, 1.75, 1.25};
float cent_on_top_s1_buf[36] = {0.5,  0.5,  0.5,  0.5, 1.67, 1.33, 1.33, 1.67, 1.33, 1.33, 1.5 , 1.5 ,
                                0. ,  0. ,  0.5,  0.5, 0.  , 0.  , 0.  , 0.  , 0.33, 0.33, 0.25, 0.25,
                                1.5,  0.5,  1.5,  0.5, 1.67, 1.33,  .67, 0.33, 0.67, 1.33, 1.75, 1.25};
/*
float strain_on_blk1_s0_buf[12] = {10.1, 10.2, 11.1, 11.2, 12.1, 12.2, 13.1, 13.2, 14.1, 14.2, 15.1, 15.2};
float strain_on_blk1_s1_buf[12] = {10.1, 10.2, 11.1, 11.2, 12.1, 12.2, 13.1, 13.2, 14.1, 14.2, 15.1, 15.2};
*/
float strain_on_blk1_s0_buf[12] = {10.0, 10.1, 20.0, 20.1, 30.0, 30.1, 40.0, 40.1, 50.0, 50.1, 60.0, 60.1};
float strain_on_blk1_s1_buf[12] = {10.0, 10.1, 20.0, 20.1, 30.0, 30.1, 40.0, 40.1, 50.0, 50.1, 60.0, 60.1};
float press_on_blk1_s0_buf[2] = {1000., 2000.};
float press_on_blk1_s1_buf[2] = {1000., 2000.};
/*
float stress_on_blk2_s0_buf[12] = {100., 101., 200., 201., 300., 301., 400., 401., 500., 501., 600., 601.};
float stress_on_blk2_s1_buf[12] = {100., 101., 200., 201., 300., 301., 400., 401., 500., 501., 600., 601.};
*/
float stress_on_blk2_s0_buf[12] = {100.2, 100.3, 200.2, 200.3, 300.2, 300.3, 400.2, 400.3, 500.2, 500.3, 600.2, 600.3};
float stress_on_blk2_s1_buf[12] = {100.2, 100.3, 200.2, 200.3, 300.2, 300.3, 400.2, 400.3, 500.2, 500.3, 600.2, 600.3};
float press_on_blk2_s0_buf[2] = {3000., 4000.};
float press_on_blk2_s1_buf[2] = {3000., 4000.};
/*
float strain_on_blk3_s0_buf[24] = {0.1, 0.2, 0.3, 0.4,
                                   1.1, 1.2, 1.3, 1.4,
                                   2.1, 2.2, 2.3, 2.4,
                                   3.1, 3.2, 3.3, 3.4,
                                   4.1, 4.2, 4.3, 4.4,
                                   5.1, 5.2, 5.3, 5.4};
float strain_on_blk3_s1_buf[24] = {0.1, 0.2, 0.3, 0.4,
                                   1.1, 1.2, 1.3, 1.4,
                                   2.1, 2.2, 2.3, 2.4,
                                   3.1, 3.2, 3.3, 3.4,
                                   4.1, 4.2, 4.3, 4.4,
                                   5.1, 5.2, 5.3, 5.4};
*/
float strain_on_blk3_s0_buf[24] = {10.4, 10.5, 10.6, 10.7,
                                   20.4, 20.5, 20.6, 20.7,
                                   30.4, 30.5, 30.6, 30.7,
                                   40.4, 40.5, 40.6, 40.7,
                                   50.4, 50.5, 50.6, 50.7,
                                   60.4, 60.5, 60.6, 60.7};
float strain_on_blk3_s1_buf[24] = {10.4, 10.5, 10.6, 10.7,
                                   20.4, 20.5, 20.6, 20.7,
                                   30.4, 30.5, 30.6, 30.7,
                                   40.4, 40.5, 40.6, 40.7,
                                   50.4, 50.5, 50.6, 50.7,
                                   60.4, 60.5, 60.6, 60.7};
/*
float stress_on_blk5_s0_buf[12] = {100.,101.,200.,201.,300.,301.,400.,401.,500.,501.,600.,601.};
float stress_on_blk5_s1_buf[12] = {100.,101.,200.,201.,300.,301.,400.,401.,500.,501.,600.,601.};
*/
float stress_on_blk5_s0_buf[12] = {100.1,100.11,200.1,200.11,300.1,300.11,400.1,400.11,500.1,500.11,600.1,600.11};
float stress_on_blk5_s1_buf[12] = {100.1,100.11,200.1,200.11,300.1,300.11,400.1,400.11,500.1,500.11,600.1,600.11};
int block1_topo_buf[8] = {3, 4, 7, 6, 0, 1, 4, 3};
int block2_topo_buf[16] = {3, 4, 14, 13, 6, 7, 10, 9, 0, 1, 12, 11, 3, 4, 14, 13};
int block3_topo_buf[12] = {7, 5, 8, 4, 5, 7, 4, 1, 5, 1, 2, 5};
int block4_topo_buf[10] = {4, 14, 10, 7, 5, 1, 12, 14, 4, 5};
int block5_topo_buf[8] = {7, 5, 10, 8, 1, 2, 12, 5};

int g_quiet=0;

/*---------------------------------------------------------------------------------------------------------------------------------
 * Data structures for the field cache.
 *---------------------------------------------------------------------------------------------------------------------------------
*/

typedef struct
{
   char        *name;
   SAF_Field    field;
} field_cache_entry;

typedef struct
{
  int ngroups;
  int *nstates;
  int *nfields;
  field_cache_entry **fields;
} field_cache;

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Create a cache of the fields in the specified suite.
 *
 * Description: This function reads the states of the specified suite and creates a cache of all the
 *              fields.  The fields can then be accessed by specifying the state and name of the desired
 *              field.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
field_cache *create_field_cache(SAF_Db *db, const char *name);
field_cache *create_field_cache(SAF_Db *db, const char *name)
{
  int num_suites, l_whichGrp;
  SAF_Suite *suites;
  int num_state_grps;
  SAF_StateGrp *state_grps;
  field_cache *cache;
  int i;


  /* Find the suites */
  num_suites = 0;
  suites = NULL;
  saf_find_suites(SAF_ALL, db, name, &num_suites, &suites);

  if (num_suites != 1)
    {
      printf("Expecting 1 suite with the name %s, found %d.\n", name,num_suites);
      return NULL;
    }

  /* Find the state groups associated with the field */
  num_state_grps = 0;
  state_grps = NULL;
  saf_find_state_groups(SAF_ALL, &(suites[0]), SAF_ANY_NAME, &num_state_grps, &state_grps);

  if (num_state_grps != 2)
    {
      printf("Expecting 2 state groups associated with %s, found %d.\n", name,num_state_grps);
      return NULL;
    }

  /*allocate*/
  cache = calloc(1, sizeof(field_cache));
  cache->ngroups = num_state_grps;
  cache->nstates = (int *)malloc(cache->ngroups*sizeof(int));
  cache->nfields = (int *)malloc(cache->ngroups*sizeof(int));
  cache->fields = (field_cache_entry **)malloc(cache->ngroups*sizeof(field_cache_entry *));

  for(l_whichGrp=0;l_whichGrp<cache->ngroups;l_whichGrp++)
    {
      SAF_StateTmpl stmpl;
      int num_states;
      int num_ftmpls;

      /* Determine the number of states in the state group. */
      num_states = 0;
      saf_describe_state_group(SAF_ALL, &(state_grps[l_whichGrp]), NULL, NULL, &stmpl, NULL, NULL, NULL, &num_states);

      /* Determine the number of fields per state. */
      num_ftmpls = 0;
      saf_describe_state_tmpl(SAF_ALL, &stmpl, NULL, &num_ftmpls, NULL);

      cache->nstates[l_whichGrp] = num_states;
      cache->nfields[l_whichGrp] = num_ftmpls;
      cache->fields[l_whichGrp] = calloc( (size_t)(num_states*num_ftmpls), sizeof(field_cache_entry));

      /* Loop over the states adding the names and field handles to the cache. */
      for (i = 0; i < num_states; i++)
	{
	  int index[3];
	  float l_timeValue=0;
	  SAF_Field *fields;
	  int j;

	  /* Read the field handles of the fields in the state. */
	  index[0] = i;
	  fields = NULL;
	  saf_read_state(SAF_ALL, &(state_grps[l_whichGrp]), i, NULL, NULL, &l_timeValue, &fields);

	  /* Loop over the fields adding the names and field handles to the cache. */
	  for (j = 0; j < num_ftmpls; j++)
	    {
	      char *name=NULL;
	      saf_describe_field(SAF_ALL, &(fields[j]), NULL, &name, NULL, NULL, NULL, NULL, NULL,
				 NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	      cache->fields[l_whichGrp][i*cache->nfields[l_whichGrp]+j].name = name;
	      cache->fields[l_whichGrp][i*cache->nfields[l_whichGrp]+j].field = fields[j];
	    }

	  if(fields) free(fields);
	}
    }

  return cache;
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Free the storage associated with a field cache.
 *
 * Description: This function frees the memory associated with a field cache.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
void free_field_cache(field_cache *cache);
void free_field_cache(field_cache *cache)
{
  int i, l_whichGrp;

  if (cache == NULL)
    return;

  for(l_whichGrp=0;l_whichGrp<cache->ngroups;l_whichGrp++)
    {
      for (i = 0; i < cache->nstates[l_whichGrp] * cache->nfields[l_whichGrp]; i++)
	{
	  free(cache->fields[l_whichGrp][i].name);
	}
      free(cache->fields[l_whichGrp]);
    }
  free(cache->nstates);
  free(cache->nfields);
  free(cache->fields);
  free(cache);
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Get the field with the specified name and state from the cache.
 *
 * Description: This function returns the field associated with the specified name and state from a field
 *              cache.  If the field is not found in the cache then it returns SAF_ERROR_FIELD.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
SAF_Field get_field_from_field_cache(field_cache *cache, int grp, int state, const char *name);
SAF_Field get_field_from_field_cache(field_cache *cache, int grp, int state, const char *name)
{
   SAF_Field field;
   int i;

   if (grp<0 || state<0 || grp>=cache->ngroups || state>=cache->nstates[grp] )
      return SS_FIELD_NULL;

   /* Loop over the fields associated with the state looking for a match on the name. */
   field = SS_FIELD_NULL;
   for (i = 0; i < cache->nfields[grp]; i++)
   {
      if (strcmp(name, cache->fields[grp][state*cache->nfields[grp]+i].name) == 0)
         field = cache->fields[grp][state*cache->nfields[grp]+i].field;
   }

   return field;
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Read and verify a remapped topology.
 *
 * Description: This function reads a topological relation on the decomposition set "set" with the range
 *              set "top_set" and the range category nodes.  Once it has read the topology it prints out
 *              the topology and then compares the results with the contents of "buf" if it is supplied.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
void read_verify_topology(SAF_Db *db, SAF_Set top_set, SAF_Set set, void *buf, int *passCount, int *failCount);
void read_verify_topology(SAF_Db *db, SAF_Set top_set, SAF_Set set, void *buf, int *passCount, int *failCount)
{
  size_t j, k, kmax;
  int num_rels;
  SAF_Rel *rels;

  hbool_t is_self_stored;
  char self_stored_str[16];

  SAF_RelRep PrepType;
  SAF_RelTarget reltarget;
  size_t abuf_size;
  hid_t abuf_type;
  size_t bbuf_size;
  hid_t bbuf_type;

  int match;

  void *abuf;
  void *bbuf;

  /* Find all the topological relations on the set. */
  num_rels = 0;
  rels = NULL;
  saf_find_topo_relations(SAF_ALL, db, &set, NULL, &num_rels, &rels);

  if (num_rels != 1)
    {
      failCount += 1;
      printf("Expecting 1 relation on the set.\n");
      printf("Found %d matching that criteria.\n", num_rels);
      return;
    }

  /* If the topological relation is not self stored then remap it. */
  saf_is_self_stored_topo_relation(SAF_ALL, &(rels[0]), &is_self_stored);

  if (!is_self_stored)
    {
      int num_cats;
      SAF_Cat *cats;

      num_cats = 0;
      cats = NULL;
      saf_find_categories(SAF_ALL, db, &top_set, "nodes", SAF_ANY_ROLE, 0, &num_cats, &cats);

      if (num_cats != 1)
	{
	  printf("Expecting 1 collection category named nodes on the top set.\n");
	  printf("Found %d matching that criteria.\n", num_cats);
	  return;
	}

      saf_target_topo_relation(&reltarget, &top_set, &(cats[0]),
                               SAF_SELF(db), SAF_UNSTRUCTURED, H5I_INVALID_HID);

      free(cats);
    }

  saf_get_count_and_type_for_topo_relation(SAF_ALL, &(rels[0]), &reltarget, &PrepType,
					   &abuf_size, &abuf_type,
					   &bbuf_size, &bbuf_type);

  /* Print out information about the topo relation */
  if (is_self_stored)
    {
      strcpy(self_stored_str, "true");
    }
  else
    {
      strcpy(self_stored_str, "false");
    }
  if(!g_quiet) printf("topo relation: self stored=%s, abuf_size=%d, bbuf_size=%d\n",
		      self_stored_str, abuf_size, bbuf_size);

  /* Read the topology */
  abuf = NULL;
  bbuf = NULL;
  saf_read_topo_relation(SAF_ALL, &(rels[0]), &reltarget, &abuf, &bbuf);

  /* Print and verify the topology */
  if(!g_quiet) printf("abuf[0]=%lu\n", (unsigned long)*(size_t*)abuf);
  for (j = 0; j < bbuf_size; j+=NUMBERS_PER_LINE)
    {
      if(!g_quiet) printf("bbuf[%d]=", j);
      kmax = (j + NUMBERS_PER_LINE) < (bbuf_size) ? (j + NUMBERS_PER_LINE) : (bbuf_size);
      if(!g_quiet) 
	{
	  for (k = j; k < kmax; k++)
              printf("%lu,", (unsigned long)((size_t*)bbuf)[k]);
	  printf("\n");
	}
    }
  if (buf != NULL)
    {
      match = 1;
      for (j = 0; j < bbuf_size; j++)
	{
	  if (((size_t*)bbuf)[j] != ((int*)buf)[j])
            match = 0;
	}
      if(!g_quiet) printf("The buffers %smatch\n", ((match == 1) ? "" : "don't "));
      *passCount += (match == 1) ? 1 : 0;
      *failCount += (match == 1) ? 0 : 1;
    }

  free(abuf);
  free(bbuf);

  free(rels);
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Read and verify a remapped topology.
 *
 * Description: This function reads "nstates" fields with the name "name".  It finds the field handle
 *              using the field cache passed to it, which returns field handles given a state number and
 *              field name.  If the field is not self stored then the field is remapped.  Once it has read
 *              the field it prints out the field and then compares the results with the contents of "bufs"
 *              if it is supplied.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
void read_verify_field(SAF_Db *db, field_cache *cache, int grp, const char *name, int nstates, void **bufs,
                  int *passCount, int *failCount);

void read_verify_field(SAF_Db *db, field_cache *cache, int grp, const char *name, int nstates, void **bufs,
                  int *passCount, int *failCount)
{
  int i;

  /* Loop over all states reading and verifying each one, remapping
     the fields to the top set. */
  for(i = 0; i < nstates; i++)
    {
      SAF_Field field;
      SAF_FieldTarget ftarg;
      hbool_t is_self_stored;

      size_t buf_size;
      hid_t buf_type;

      void *buf;

      size_t j, k, kmax;
      char self_stored_str[16];
      char buf_type_str[16];
      int match;

      /* Get the field handle for the specified name and state. */
      field = get_field_from_field_cache(cache, grp, i, name);

      if (SS_PERS_ISNULL(&field))
	{
	  failCount++;
	  printf("Couldn't read field %s from state group %d, state %d\n", name, grp, i);
	  return;
	}

      saf_is_self_stored_field(SAF_ALL, &field, &is_self_stored);

      if (!is_self_stored)
	{
	  saf_target_field(&ftarg, NULL, SAF_SELF(db),
			   SAF_ANY_CAT, SAF_ANY_RATIO, SAF_ANY_CAT, SAF_ANY_EFUNC, H5I_INVALID_HID,
			   SAF_INTERLEAVE_COMPONENT, NULL);
	}

      saf_get_count_and_type_for_field(SAF_ALL, &field, &ftarg, &buf_size,
                                       &buf_type);

      /* Print out information about the field */
      if (is_self_stored)
	{
	  strcpy(self_stored_str, "true");
	}
      else
	{
	  strcpy(self_stored_str, "false");
	}
      if (H5Tequal(buf_type, SAF_FLOAT))
	{
	  strcpy(buf_type_str, "float");
	}
      else if (H5Tequal(buf_type, SAF_DOUBLE))
	{
	  strcpy(buf_type_str, "double");
	}
      else if (H5Tequal(buf_type, SAF_INT))
	{
	  strcpy(buf_type_str, "int");
	}
      else
	{
	  strcpy(buf_type_str, "unknown");
	}
      if(!g_quiet) printf("Field %s occurance %d: self stored=%s, size=%d, type=%s\n",
			  name, i, self_stored_str, buf_size, buf_type_str);

      /* Read the field */
      buf = NULL;
      saf_read_field(SAF_ALL, &field, &ftarg, SAF_WHOLE_FIELD, &buf);

      /* Print and verify the field */
      if (H5Tequal(buf_type, SAF_FLOAT))
	{
	  for (j = 0; j < buf_size; j+=NUMBERS_PER_LINE)
	    {
	      if(!g_quiet)printf("buf[%d]=", j);
	      kmax = (j + NUMBERS_PER_LINE) < (buf_size) ? (j + NUMBERS_PER_LINE) : (buf_size);
	      if(!g_quiet)
		{
		  for (k = j; k < kmax; k++)
		    printf("%g,", ((float *)buf)[k]);
		  printf("\n");
		}
	    }
	  if (bufs != NULL)
	    {
	      match = 1;
	      for (j = 0; j < buf_size; j++)
		{
		  if (((float *)buf)[j] != ((float *)bufs[i])[j])
		    match = 0;
		}
	      if(!g_quiet) printf("The buffers %smatch\n", ((match == 1) ? "" : "don't "));
	      *passCount += ((match == 1) ? 1 : 0);
	      *failCount += ((match == 1) ? 0 : 1);
	    }
	}
      else if (H5Tequal(buf_type, SAF_DOUBLE))
	{
	  for (j = 0; j < buf_size; j+=NUMBERS_PER_LINE)
	    {
	      if(!g_quiet) printf("buf[%d]=", j);
	      kmax = (j + NUMBERS_PER_LINE) < (buf_size) ? (j + NUMBERS_PER_LINE) : (buf_size);
	      if(!g_quiet)
		{
	      for (k = j; k < kmax; k++)
		printf("%g,", ((double *)buf)[k]);
	      printf("\n");
		}
	    }
	  if (bufs != NULL)
	    {
	      match = 1;
	      for (j = 0; j < buf_size; j++)
		{
		  if (((double *)buf)[j] != ((double *)bufs[i])[j])
		    match = 0;
		}
	      if(!g_quiet) printf("The buffers %smatch\n", ((match == 1) ? "" : "don't "));
	      *passCount += (match == 1) ? 1 : 0;
	      *failCount += (match == 1) ? 0 : 1;
	    }
	}
      else if (H5Tequal(buf_type, SAF_INT))
	{
	  for (j = 0; j < buf_size; j+=NUMBERS_PER_LINE)
	    {
	      if(!g_quiet) printf("buf[%d]=", j);
	      kmax = (j + NUMBERS_PER_LINE) < (buf_size) ? (j + NUMBERS_PER_LINE) : (buf_size);
	      if(!g_quiet)
		{
	      for (k = j; k < kmax; k++)
		printf("%d,", ((int *)buf)[k]);
	      printf("\n");
		}
	    }
	  if (bufs != NULL)
	    {
	      match = 1;
	      for (j = 0; j < buf_size; j++)
		{
		  if (((int *)buf)[j] != ((int *)bufs[i])[j])
		    match = 0;
		}
	      if(!g_quiet) printf("The buffers %smatch\n", ((match == 1) ? "" : "don't "));
	      *passCount += (match == 1) ? 1 : 0;
	      *failCount += (match == 1) ? 0 : 1;
	    }
	}

      free(buf);
    }
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Read and verify field remapping on the top set.
 *
 * Description: This function reads and verifies a set of fields on the top set.  The set of field names is
 *              hardwired into the code.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
void read_verify_top_set(SAF_Db *db, field_cache *time_cache,
			 int *passCount, int *failCount);
void read_verify_top_set(SAF_Db *db, field_cache *time_cache,
			 int *passCount, int *failCount)
{
   void *bufs[2];
   int group;

   if(!g_quiet) printf("Processing TOP_SET.\n");

   group=0;
   bufs[0] = (void *) coords_on_top_buf;
   read_verify_field(db, time_cache, group, "coords_on_top", 1, bufs, passCount, failCount);

   group=1;
   bufs[0] = (void *) disp_on_top_s0_buf;
   bufs[1] = (void *) disp_on_top_s1_buf;
   read_verify_field(db, time_cache, group, "disp_on_top", 2, bufs, passCount, failCount);
   bufs[0] = (void *) vel_on_top_s0_buf;
   bufs[1] = (void *) vel_on_top_s1_buf;
   read_verify_field(db, time_cache, group, "vel_on_top", 2, bufs, passCount, failCount);
   bufs[0] = (void *) elem_ids_on_top_s0_buf;
   bufs[1] = (void *) elem_ids_on_top_s1_buf;
   read_verify_field(db, time_cache, group, "elem_ids_on_top", 2, bufs, passCount, failCount);
   bufs[0] = (void *) cent_on_top_s0_buf;
   bufs[1] = (void *) cent_on_top_s1_buf;
   read_verify_field(db, time_cache, group, "cent_on_top", 2, bufs, passCount, failCount);
}

/*---------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Read and verify field and topology remapping on the block sets.
 *
 * Description: This function reads and verifies a set of fields on each of the block sets, as well as
 *              reading and verifying the topology on each of the block sets.  The set of block sets is
 *              hardwired into the function, as is the names of the fields that it reads on each of the
 *              specific blocks.
 *---------------------------------------------------------------------------------------------------------------------------------
*/
void read_verify_block_sets(SAF_Db *db, field_cache *cache, int *passCount, int *failCount);
void read_verify_block_sets(SAF_Db *db, field_cache *cache, int *passCount, int *failCount)
{
   SAF_Set top_set;
   int num_sets;
   SAF_Set *sets;
   void    *bufs[2];
   int group=1;

   /* Find the top set */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "TOP_SET", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_TORF, &num_sets, &sets);

   if (num_sets != 1)
   {
      failCount += 1;
      printf("Expecting a single set with the name TOP_SET.\n");
      printf("Found %d matching that criteria.\n", num_sets);
      return;
   }

   top_set = sets[0];
   free(sets);
   
   /* Process BLOCK_1 */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "BLOCK_1", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_FALSE, &num_sets, &sets);

   if (num_sets == 1)
   {
      if(!g_quiet) printf("Processing BLOCK_1\n");

      read_verify_topology(db, top_set, sets[0], block1_topo_buf, passCount, failCount);

      bufs[0] = strain_on_blk1_s0_buf;
      bufs[1] = strain_on_blk1_s1_buf;
      read_verify_field(db, cache, group, "strain_on_blk1", 2, bufs, passCount, failCount);
      bufs[0] = press_on_blk1_s0_buf;
      bufs[1] = press_on_blk1_s1_buf;
      read_verify_field(db, cache, group, "press_on_blk1", 2, bufs, passCount, failCount);
   }
   else
   {
      failCount += 1;
      printf("Warning: BLOCK_1 set not found, skipping it.\n");
   }

   free(sets);

   /* Process BLOCK_2 */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "BLOCK_2", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_FALSE, &num_sets, &sets);

   if (num_sets == 1)
   {
      if(!g_quiet) printf("Processing BLOCK_2\n");

      read_verify_topology(db, top_set, sets[0], block2_topo_buf, passCount, failCount);

      bufs[0] = stress_on_blk2_s0_buf;
      bufs[1] = stress_on_blk2_s1_buf;
      read_verify_field(db, cache,  group, "stress_on_blk2", 2, bufs, passCount, failCount);
      bufs[0] = press_on_blk2_s0_buf;
      bufs[1] = press_on_blk2_s1_buf;
      read_verify_field(db, cache,  group, "press_on_blk2", 2, bufs, passCount, failCount);
   }
   else
   {
      failCount += 1;
      printf("Warning: BLOCK_2 set not found, skipping it.\n");
   }

   free(sets);

   /* Process BLOCK_3 */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "BLOCK_3", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_FALSE, &num_sets, &sets);

   if (num_sets == 1)
   {
      if(!g_quiet) printf("Processing BLOCK_3\n");

      read_verify_topology(db, top_set, sets[0], block3_topo_buf, passCount, failCount);

      bufs[0] = strain_on_blk3_s0_buf;
      bufs[1] = strain_on_blk3_s1_buf;
      read_verify_field(db, cache,  group, "strain_on_blk3", 2, bufs, passCount, failCount);
   }
   else
   {
      failCount += 1;
      printf("Warning: BLOCK_3 set not found, skipping it.\n");
   }

   free(sets);

   /* Process BLOCK_4 */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "BLOCK_4", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_FALSE, &num_sets, &sets);

   if (num_sets == 1)
   {
      if(!g_quiet) printf("Processing BLOCK_4\n");

      read_verify_topology(db, top_set, sets[0], block4_topo_buf, passCount, failCount);
   }
   else
   {
      failCount += 1;
      printf("Warning: BLOCK_4 set not found, skipping it.\n");
   }

   free(sets);

   /* Process BLOCK_5 */
   num_sets = 0;
   sets = NULL;
   saf_find_matching_sets(SAF_ALL, db, "BLOCK_5", SAF_SPACE,
                          SAF_ANY_TOPODIM, SAF_EXTENDIBLE_TORF,
                          SAF_TOP_FALSE, &num_sets, &sets);

   if (num_sets == 1)
   {
      if(!g_quiet) printf("Processing BLOCK_5\n");

      read_verify_topology(db, top_set, sets[0], block5_topo_buf, passCount, failCount);

      bufs[0] = stress_on_blk5_s0_buf;
      bufs[1] = stress_on_blk5_s1_buf;
      read_verify_field(db, cache,  group, "stress_on_blk5", 2, bufs, passCount, failCount);
   }
   else
   {
      failCount += 1;
      printf("Warning: BLOCK_5 set not found, skipping it.\n");
   }

   free(sets);
}

/*-------------------------------------------------------------------------------------------------------------------------------
 * Audience:    Public
 * Chapter:     N to 1 Remapping Use Case
 * Purpose:     Main entry point
 *
 * Description: See [N to 1 Remapping Use Case].
 *-------------------------------------------------------------------------------------------------------------------------------
 */
int
main(int argc, char **argv)
{
  char dbname[1024];        /* Name of the SAF database file to be read. */
  SAF_Db *db=NULL;                /* Handle to the SAF database. */
  SAF_DbProps *dbprops=NULL;      /* Handle to the SAF database properties. */
  int failCount = 0;
  int passCount = 0;
  int numProcs = 1;

  /* this use-case example is designed to read the database generated by
     exo_par_wt, which is only generated when building a parallel version
     of SAF. Nonetheless, this example is, in fact, a serial example.
     Consequently, this use-case test is only run in single processor
     parallel (I guess we should start calling this pseudo-serial) */ 
#ifndef HAVE_PARALLEL
  saf_init(SAF_DEFAULT_LIBPROPS);
  saf_final();
  SKIPPED;
  return(0);
#else
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &numProcs);
  if (numProcs != 1)
    {
      printf("This example must be run using MPI, but with only 1 proc (now is %d)\n",numProcs);
      SKIPPED;
      MPI_Finalize();
      return(0);
    }
#endif

  if( argc>=2 && !strcmp(argv[1],"-quiet") ) g_quiet=1;

  /* for convenience, set working directory to the test file directory */
  chdir(TEST_FILE_PATH);

  /* Get the name of the SAF database. */
  strcpy(dbname, "exo_par_wt.saf");

  /* Initialize the library. */
  saf_init(SAF_DEFAULT_LIBPROPS);

  SAF_TRY_BEGIN
    {
      field_cache *time_cache;

      /* Because we are in a try block here, all failures will send us to
         the one and only catch block at the end of this test */

      /* Create the database properties. */
      dbprops = saf_createProps_database();

      /* Set the read-only database property. */
      saf_setProps_ReadOnly(dbprops);

      /* Open the SAF database. Give it name dbname, properties dbprops
       * and set db to be a handle to this database. */
      db = saf_open_database(dbname,dbprops);

      /* Create caches of the field handles from the suites in the
       * database. */
      time_cache = create_field_cache(db, "TIME_SUITE");

      if (time_cache != NULL)
	{
	  read_verify_top_set(db, time_cache, &passCount, &failCount);

	  read_verify_block_sets(db, time_cache, &passCount, &failCount);
	}
      else
	{
	  FAILED;
	}

      /* Free the field handle caches. */
      free_field_cache(time_cache);
      
      /* Close the SAF database. */
      saf_close_database(db);
    }
  SAF_CATCH
    {
      SAF_CATCH_ALL
	{
	  FAILED;
	}
    }
  SAF_TRY_END

    /* Finalize access to the library. */
    saf_final();

  printf("%d tests performed:    PASSED=%d, FAILED=%d\n", passCount + failCount, passCount, failCount);


  if (failCount)
    FAILED;
  else
    PASSED;

#ifdef HAVE_PARALLEL
  MPI_Bcast(&failCount, 1, MPI_INT, 0, MPI_COMM_WORLD);
  MPI_Finalize();
#endif

  return failCount;
}
